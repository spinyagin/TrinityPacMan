diff --git a/sql/updates/world/3.3.5/2023_12_09_00_world.sql b/sql/updates/world/3.3.5/2023_12_09_00_world.sql
new file mode 100644
index 0000000000..ad38f6d439
--- /dev/null
+++ b/sql/updates/world/3.3.5/2023_12_09_00_world.sql
@@ -0,0 +1,36 @@
+INSERT INTO npc_text (ID,text0_0,text0_1,BroadcastTextID0,lang0,Probability0,EmoteDelay0_0,Emote0_0,EmoteDelay0_1,Emote0_1,EmoteDelay0_2,Emote0_2,text1_0,text1_1,BroadcastTextID1,lang1,Probability1,EmoteDelay1_0,Emote1_0,EmoteDelay1_1,Emote1_1,EmoteDelay1_2,Emote1_2,text2_0,text2_1,BroadcastTextID2,lang2,Probability2,EmoteDelay2_0,Emote2_0,EmoteDelay2_1,Emote2_1,EmoteDelay2_2,Emote2_2,text3_0,text3_1,BroadcastTextID3,lang3,Probability3,EmoteDelay3_0,Emote3_0,EmoteDelay3_1,Emote3_1,EmoteDelay3_2,Emote3_2,text4_0,text4_1,BroadcastTextID4,lang4,Probability4,EmoteDelay4_0,Emote4_0,EmoteDelay4_1,Emote4_1,EmoteDelay4_2,Emote4_2,text5_0,text5_1,BroadcastTextID5,lang5,Probability5,EmoteDelay5_0,Emote5_0,EmoteDelay5_1,Emote5_1,EmoteDelay5_2,Emote5_2,text6_0,text6_1,BroadcastTextID6,lang6,Probability6,EmoteDelay6_0,Emote6_0,EmoteDelay6_1,Emote6_1,EmoteDelay6_2,Emote6_2,text7_0,text7_1,BroadcastTextID7,lang7,Probability7,EmoteDelay7_0,Emote7_0,EmoteDelay7_1,Emote7_1,EmoteDelay7_2,Emote7_2,VerifiedBuild) VALUES
+	 (100000,'','Hello $n! Let\'s start the game!',0,0, 0.9,0,0,0,0,0,0,'','Start now. Annoys.',0,0,0.1,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,0);
+
+INSERT INTO npc_text (ID,text0_0,text0_1,BroadcastTextID0,lang0,Probability0,EmoteDelay0_0,Emote0_0,EmoteDelay0_1,Emote0_1,EmoteDelay0_2,Emote0_2,text1_0,text1_1,BroadcastTextID1,lang1,Probability1,EmoteDelay1_0,Emote1_0,EmoteDelay1_1,Emote1_1,EmoteDelay1_2,Emote1_2,text2_0,text2_1,BroadcastTextID2,lang2,Probability2,EmoteDelay2_0,Emote2_0,EmoteDelay2_1,Emote2_1,EmoteDelay2_2,Emote2_2,text3_0,text3_1,BroadcastTextID3,lang3,Probability3,EmoteDelay3_0,Emote3_0,EmoteDelay3_1,Emote3_1,EmoteDelay3_2,Emote3_2,text4_0,text4_1,BroadcastTextID4,lang4,Probability4,EmoteDelay4_0,Emote4_0,EmoteDelay4_1,Emote4_1,EmoteDelay4_2,Emote4_2,text5_0,text5_1,BroadcastTextID5,lang5,Probability5,EmoteDelay5_0,Emote5_0,EmoteDelay5_1,Emote5_1,EmoteDelay5_2,Emote5_2,text6_0,text6_1,BroadcastTextID6,lang6,Probability6,EmoteDelay6_0,Emote6_0,EmoteDelay6_1,Emote6_1,EmoteDelay6_2,Emote6_2,text7_0,text7_1,BroadcastTextID7,lang7,Probability7,EmoteDelay7_0,Emote7_0,EmoteDelay7_1,Emote7_1,EmoteDelay7_2,Emote7_2,VerifiedBuild) VALUES
+	 (100001,'','Hello $n! I\'m busy, wait until the player finishes',0,0, 1.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,'','',0,0,0.0,0,0,0,0,0,0,0);
+
+insert into gossip_menu values (58000, 100000, 0);
+
+INSERT INTO gossip_menu_option (MenuID,OptionID,OptionIcon,OptionText,OptionBroadcastTextID,OptionType,OptionNpcFlag,ActionMenuID,ActionPoiID,BoxCoded,BoxMoney,BoxText,BoxBroadcastTextID,VerifiedBuild) VALUES
+	 (58000,0,0,'Start game',0,1,1,0,0,0,0,'',0,0);
+
+INSERT INTO creature_template  (entry,difficulty_entry_1,difficulty_entry_2,difficulty_entry_3,KillCredit1,KillCredit2,modelid1,modelid2,modelid3,modelid4,name,subname,IconName,gossip_menu_id,minlevel,maxlevel,`exp`,faction,npcflag,speed_walk,speed_run,`scale`,`rank`,dmgschool,BaseAttackTime,RangeAttackTime,BaseVariance,RangeVariance,unit_class,unit_flags,unit_flags2,dynamicflags,family,`type`,type_flags,lootid,pickpocketloot,skinloot,PetSpellDataId,VehicleId,mingold,maxgold,AIName,MovementType,HoverHeight,HealthModifier,ManaModifier,ArmorModifier,DamageModifier,ExperienceModifier,RacialLeader,movementId,RegenHealth,mechanic_immune_mask,spell_school_immune_mask,flags_extra,ScriptName,VerifiedBuild) VALUES
+	 (43500,0,0,0,0,0,28222,0,0,0,'PacManHandler','Test Assignment','',58000,83,83,2,2006,1,1.0,1.0,1.75,3,0,2000,2000,1.0,1.0,2,768,2048,0,0,5,4,0,0,0,0,0,0,0,'',0,1.0,1000.0,500.0,1.0,35.0,1.0,0,0,1,0,0,66,'npc_pacman_handler',0),
+	 (43501,0,0,0,0,0,10648,0,0,0,'Point','',NULL,0,1,2,0,7,0,1.0,1.0,2.0,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,7,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'npc_regular_point',0),
+	 (43502,0,0,0,0,0,10701,0,0,0,'Blinky','',NULL,0,80,80,0,7,0,1.0,1.0,1.5,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,6,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'npc_blinky',0),
+	 (43503,0,0,0,0,0,14592,0,0,0,'Inky','',NULL,0,80,80,0,7,0,1.0,1.0,1.4,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,6,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'npc_inky',0),
+	 (43504,0,0,0,0,0,14560,0,0,0,'Clyde','',NULL,0,80,80,0,7,0,1.0,1.0,1.0,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,6,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'npc_clyde',0),
+	 (43505,0,0,0,0,0,25144,0,0,0,'Bonus Point','',NULL,0,1,2,0,7,0,1.0,1.0,0.7,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,7,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'npc_bonus_point',0),
+	 (43506,0,0,0,0,0,25071,0,0,0,'Pac-Man','',NULL,0,1,2,0,7,0,1.0,1.0,2.0,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,7,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'',0),
+	 (43507,0,0,0,0,0,25071,0,0,0,'Fruit','',NULL,0,1,2,0,7,0,1.0,1.0,5.0,0,0,2000,2000,1.0,1.0,1,33555200,2048,0,0,7,0,0,0,0,0,0,0,0,'',0,1.0,1.0,1.0,1.0,1.0,1.0,0,100,1,0,0,2,'npc_fruit',0);
+
+INSERT INTO creature (guid, id,`map`,zoneId,areaId,spawnMask,phaseMask,modelid,equipment_id,position_x,position_y,position_z,orientation,spawntimesecs,wander_distance,currentwaypoint,curhealth,curmana,MovementType,npcflag,unit_flags,dynamicflags,ScriptName,VerifiedBuild) VALUES
+	 (220000,43500,571,0,0,1,1,0,0,7075.596058989236,4335.733579572128,871.45304465,1.323578199427277,30,0.0,0,13945000,2129000,0,0,0,0,'',0);
+
+insert into areatrigger_teleport values (6000, 'Pacman Game Location (Player Start)', 571, 7075.596058989236, 4335.733579572128, 871.45304465, 1.323578199427277, 0);
+
+insert into areatrigger_teleport values (6001, 'Pacman Game Location (NPC Vantage Point)', 571, 7087.602051, 4383.531250, 872.320068, 4.46517085301707, 0);
+
+INSERT INTO spell_dbc (ID,Dispel,Mechanic,Attributes,AttributesEx,AttributesEx2,AttributesEx3,AttributesEx4,AttributesEx5,AttributesEx6,AttributesEx7,Stances,StancesNot,Targets,CastingTimeIndex,AuraInterruptFlags,ProcFlags,ProcChance,ProcCharges,BaseLevel,SpellLevel,DurationIndex,RangeIndex,StackAmount,EquippedItemClass,EquippedItemSubClassMask,EquippedItemInventoryTypeMask,Effect1,Effect2,Effect3,EffectDieSides1,EffectDieSides2,EffectDieSides3,EffectRealPointsPerLevel1,EffectRealPointsPerLevel2,EffectRealPointsPerLevel3,EffectBasePoints1,EffectBasePoints2,EffectBasePoints3,EffectMechanic1,EffectMechanic2,EffectMechanic3,EffectImplicitTargetA1,EffectImplicitTargetA2,EffectImplicitTargetA3,EffectImplicitTargetB1,EffectImplicitTargetB2,EffectImplicitTargetB3,EffectRadiusIndex1,EffectRadiusIndex2,EffectRadiusIndex3,EffectApplyAuraName1,EffectApplyAuraName2,EffectApplyAuraName3,EffectAmplitude1,EffectAmplitude2,EffectAmplitude3,EffectMultipleValue1,EffectMultipleValue2,EffectMultipleValue3,EffectItemType1,EffectItemType2,EffectItemType3,EffectMiscValue1,EffectMiscValue2,EffectMiscValue3,EffectMiscValueB1,EffectMiscValueB2,EffectMiscValueB3,EffectTriggerSpell1,EffectTriggerSpell2,EffectTriggerSpell3,EffectSpellClassMaskA1,EffectSpellClassMaskA2,EffectSpellClassMaskA3,EffectSpellClassMaskB1,EffectSpellClassMaskB2,EffectSpellClassMaskB3,EffectSpellClassMaskC1,EffectSpellClassMaskC2,EffectSpellClassMaskC3,SpellFamilyName,SpellFamilyFlags1,SpellFamilyFlags2,PreventionType,AreaGroupID,SchoolMask) VALUES
+	 (80000,0,12,2684616704,268435592,0,196608,1048641,34,2164269060,0,0,0,0,1,0,0,101,0,50,50,28,1,0,-1,0,0,6,0,0,1,0,0,0.0,0.0,0.0,0,0,0,12,0,0,1,0,0,0,0,0,0,0,0,12,0,0,0,0,0,1.0,1.0,1.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),
+	 (80001,0,0,2147483904,268435456,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,13,15,-1,0,0,6,6,6,1,1,1,0.0,0.0,0.0,1,6,1,0,0,0,25,25,25,25,25,25,0,0,0,241,191,27,0,0,0,0.0,0.0,0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),
+	 (80002,0,0,2147483648,0,0,0,0,0,0,0,0,0,0,1,0,0,101,101,0,0,1,13,0,-1,0,0,6,6,0,1,1,0,0.0,0.0,0.0,1,1,0,0,0,0,25,25,0,25,25,0,0,0,0,25,23,0,0,500,0,0.0,0.0,0.0,0,0,0,0,0,0,0,0,0,0,18970,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),
+	 (80003,0,0,2147483648,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,9,13,100,-1,0,0,6,6,0,1,1,0,0.0,0.0,0.0,247,-10,0,0,0,0,25,25,0,25,25,0,0,0,0,3,33,0,2000,0,0,0.0,0.0,0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),
+	 (80004,0,0,2147483648,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,27,13,50,-1,0,0,6,0,0,1,1,0,0.0,0.0,0.0,-2,0,0,0,0,0,25,25,0,25,25,0,0,0,0,33,0,0,0,0,0,0.0,0.0,0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
+
+update gameobject_template set size = 1.26 where entry = 188236;
\ No newline at end of file
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 67bf9047c8..ab94bbcbe5 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7157,6 +7157,14 @@ AreaTrigger const* ObjectMgr::GetAreaTrigger(uint32 trigger) const
     return nullptr;
 }

+AreaTrigger const* ObjectMgr::GetAreaTriggerEx(uint32 trigger) const
+{
+    AreaTriggerContainer::const_iterator itr = _areaTriggerStoreEx.find(trigger);
+    if (itr != _areaTriggerStoreEx.end())
+        return &itr->second;
+    return nullptr;
+}
+
 AccessRequirement const* ObjectMgr::GetAccessRequirement(uint32 mapid, Difficulty difficulty) const
 {
     AccessRequirementContainer::const_iterator itr = _accessRequirementStore.find(MAKE_PAIR32(mapid, difficulty));
@@ -7272,14 +7280,20 @@ void ObjectMgr::LoadAreaTriggerTeleports()
         at.target_Z                 = fields[4].GetFloat();
         at.target_Orientation       = fields[5].GetFloat();

+        /* See comment for _areaTriggerStoreEx */
         AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
+        MapEntry const* mapEntry = sMapStore.LookupEntry(at.target_mapId);
+
         if (!atEntry)
         {
+            if (mapEntry && !(at.target_X == 0 && at.target_Y == 0 && at.target_Z == 0)) {
+                _areaTriggerStoreEx[Trigger_ID] = at;
+            }
+
             TC_LOG_ERROR("sql.sql", "Area trigger (ID:{}) does not exist in `AreaTrigger.dbc`.", Trigger_ID);
             continue;
         }

-        MapEntry const* mapEntry = sMapStore.LookupEntry(at.target_mapId);
         if (!mapEntry)
         {
             TC_LOG_ERROR("sql.sql", "Area trigger (ID:{}) target map (ID: {}) does not exist in `Map.dbc`.", Trigger_ID, at.target_mapId);
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 6eb3976784..ea7b332eba 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -1065,6 +1065,7 @@ class TC_GAME_API ObjectMgr
         GraveyardData const* FindGraveyardData(uint32 id, uint32 zone) const;

         AreaTrigger const* GetAreaTrigger(uint32 trigger) const;
+        AreaTrigger const* GetAreaTriggerEx(uint32 trigger) const;
         AccessRequirement const* GetAccessRequirement(uint32 mapid, Difficulty difficulty) const;
         AreaTrigger const* GetGoBackTrigger(uint32 Map) const;
         AreaTrigger const* GetMapEntranceTrigger(uint32 Map) const;
@@ -1630,6 +1631,9 @@ class TC_GAME_API ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;

+        /* Initially, it is assumed that i cannot edit the DBC within the framework of the assignment, so i create a separate container for areatrigger_teleport that do not exist in the DBC */
+        AreaTriggerContainer _areaTriggerStoreEx;
+
     private:
         void LoadScripts(ScriptsType type);
         void LoadQuestRelationsHelper(QuestRelations& map, std::string const& table);
diff --git a/src/server/scripts/Commands/cs_go.cpp b/src/server/scripts/Commands/cs_go.cpp
index 22cf5b2e36..1df8b8c0f4 100644
--- a/src/server/scripts/Commands/cs_go.cpp
+++ b/src/server/scripts/Commands/cs_go.cpp
@@ -248,6 +248,12 @@ public:
         AreaTriggerEntry const* at = sAreaTriggerStore.LookupEntry(areaTriggerId);
         if (!at)
         {
+            /* DEBUG assume that continentid == mapid */
+            AreaTrigger const* at = sObjectMgr->GetAreaTriggerEx(areaTriggerId);
+            if (at) {
+                return DoTeleport(handler, { at->target_X, at->target_Y, at->target_Z, at->target_Orientation }, at->target_mapId);
+            }
+            /* DEBUG */
             handler->PSendSysMessage(LANG_COMMAND_GOAREATRNOTFOUND, areaTriggerId);
             handler->SetSentErrorMessage(true);
             return false;
diff --git a/src/server/scripts/Custom/GhostAI.cpp b/src/server/scripts/Custom/GhostAI.cpp
new file mode 100644
index 0000000000..4372682176
--- /dev/null
+++ b/src/server/scripts/Custom/GhostAI.cpp
@@ -0,0 +1,254 @@
+#include "GhostAI.h"
+#include "ObjectAccessor.h"
+namespace PacMan {
+    GhostAI::GhostAI(Creature* creature) : ScriptedAI(creature)
+    {
+
+    }
+
+    void GhostAI::InitializeAI()
+    {
+        /* you can load map from another source  */
+        try {
+            _mapManager = std::make_unique<MapManager>(TXT_MAP);
+            _mapManager->parse();
+            _mapManager->calculateArea(POS_MAP);
+            _pathFinder = std::make_unique<PathFinder>(_mapManager->getGrid());
+        }
+        catch (std::exception& /*e*/) {
+            me->KillSelf();
+            return;
+        }
+
+        _defautlSpeed = me->GetSpeed(MOVE_RUN);
+        me->CastSpell(nullptr, SPELL_STUN_VISUAL);
+        _state = EAIState::AI_STATE_SCATTER;
+        /* else trigger by eated points */
+    }
+
+    void GhostAI::Reset()
+    {
+        _events.Reset();
+    }
+
+    void GhostAI::OnDespawn()
+    {
+        _events.Reset();
+    }
+
+    void GhostAI::DoAction(int32 action)
+    {
+        if (action == GHOST_FIND_TARGET_POINT) {
+            Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+            if (!player) {
+                return;
+            }
+
+            Position playerPosition = player->GetPosition();
+            Position myPosition = me->GetPosition();
+
+            std::pair<int32_t, int32_t> myPseudoPosition = _mapManager->toPseudoCellTransform(myPosition);
+            std::pair<int32_t, int32_t> playerPseudoPosition = _mapManager->toPseudoCellTransform(playerPosition);
+
+            switch (_state) {
+                case EAIState::AI_STATE_SCATTER: {
+                    Position position = me->GetPosition();
+                    std::pair<int32_t, int32_t> pseudoPosition = _mapManager->toPseudoCellTransform(position);
+
+                    if (myPseudoPosition == playerPseudoPosition) {
+                        return PlayerCatched();
+                    }
+
+                    if (_pathFinder->isAdjacent(pseudoPosition, _currentTarget) || !me->isMoving() || _forceChangePath) {
+                        std::pair<int32_t, int32_t> _currentTarget = _scatterPositions.front();
+                        _scatterPositions.pop();
+                        _scatterPositions.push(_currentTarget);
+
+                        std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(pseudoPosition, _currentTarget, 100));
+                        me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);
+                    }
+                    break;
+                }
+                case EAIState::AI_STATE_FRIGHTEND: {
+                    if (myPseudoPosition == playerPseudoPosition) {
+                        me->GetAI()->DoAction(GHOST_LOSE);
+
+                        srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+                        int32_t random = rand() % 10;
+                        me->Say(sprintf(GHOST_SAYS_WHEN_WAS_EATEN[random], player->GetName().c_str()), LANG_UNIVERSAL);
+
+                        me->RemoveAurasDueToSpell(SPELL_FEAR_VISUAL);
+                        _isFeightDeath = true;
+                        me->CastSpell(me, SPELL_FEIGN_DEATH);
+                        _events.Reset();
+                        _events.ScheduleEvent(GHOST_BACK_TO_START, GHOST_RESPAWN_TIME);
+
+                        /* TODO: add some visual effects */
+
+                        return;
+                    }
+
+                    if (_pathFinder->isAdjacent(myPseudoPosition, _currentTarget) || !me->isMoving() || _forceChangePath) {
+                        std::pair<int32_t, int32_t> _currentTarget = _mapManager->getRandomNearPointEx(myPseudoPosition.first, myPseudoPosition.second);
+                        std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(myPseudoPosition, _currentTarget, 42)); // depth an magic number need to tune this method
+
+                        me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);  //MovePath(path, false);
+                    }
+                    break;
+                }
+                default:
+                    break;
+            }
+
+            _forceChangePath = false;
+            _events.RescheduleEvent(GHOST_FIND_TARGET_POINT, 100ms);
+        }
+        else if (action == BONUS_POINT_DESPAWN) {
+            _state = EAIState::AI_STATE_FRIGHTEND;
+            me->CastSpell(nullptr, SPELL_FEAR_VISUAL);
+            me->CastSpell(me, SPELL_NPC_CHANGE_STATE_VISUAL);
+            _events.RescheduleEvent(GHOST_CHANGE_STATE, GHOST_AI_FRIGHTENED_TIME);
+
+            Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+            if (player) {
+                srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+                int32_t random = rand() % 10;
+                me->Yell(sprintf(GHOST_SAY_WHEN_WAS_FRIGHTENED[random], player->GetName().c_str()), LANG_UNIVERSAL);
+            }
+
+            me->SetSpeed(MOVE_RUN, _defautlSpeed * 0.6f); // - 40% speed
+
+            _forceChangePath = true;
+        }
+        else if (_isFeightDeath) {
+            /* prevent replica when _isFeightDeath */
+            return;
+        }
+        else if (action == INKY_WIN) {
+            srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+            int32_t random = rand() % 10;
+            me->Yell(sprintf(GHOSTS_SAYS_WHEN_ANOTHER_ONE_CATCH_PLAYER[random], "Inky"), LANG_UNIVERSAL);
+            PlayerCatched(false);
+        }
+        else if (action == CLYDE_WIN) {
+            srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+            int32_t random = rand() % 10;
+            me->Yell(sprintf(GHOSTS_SAYS_WHEN_ANOTHER_ONE_CATCH_PLAYER[random], "Clyde"), LANG_UNIVERSAL);
+            PlayerCatched(false);
+        }
+        else if (action == INKY_LOSE) {
+            srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+            int32_t random = rand() % 10;
+            me->Yell(sprintf(GHOSTS_SAYS_WHEN_ANOTHER_ONE_IS_EATEN[random], "Inky"), LANG_UNIVERSAL);
+        }
+        else if (action == CLYDE_LOSE) {
+            srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+            int32_t random = rand() % 10;
+            me->Yell(sprintf(GHOSTS_SAYS_WHEN_ANOTHER_ONE_IS_EATEN[random], "Clyde"), LANG_UNIVERSAL);
+        }
+        else if (action == BLINKY_LOSE) {
+            srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+            int32_t random = rand() % 10;
+            me->Yell(sprintf(GHOSTS_SAYS_WHEN_ANOTHER_ONE_IS_EATEN[random], "Blinky"), LANG_UNIVERSAL);
+        }
+        else if (action == BLINKY_WIN) {
+            srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+            int32_t random = rand() % 10;
+            me->Yell(sprintf(GHOSTS_SAYS_WHEN_ANOTHER_ONE_CATCH_PLAYER[random], "Blinky"), LANG_UNIVERSAL);
+            PlayerCatched(false);
+        }
+        else if (action == STOP_GHOSTS) {
+            _events.Reset();
+        }
+    }
+
+    void GhostAI::UpdateAI(uint32 diff)
+    {
+        _events.Update(diff);
+
+        switch (_events.ExecuteEvent()) {
+            case GHOST_DELAYED_START: {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    _playerGuid = owner->GetAI()->GetGUID(GET_CURRENT_PLAYER);
+                }
+                else {
+                    _playerGuid = ObjectGuid::Empty;
+                }
+                me->RemoveAurasDueToSpell(SPELL_STUN_VISUAL);
+                _startPosition = me->GetPosition();
+                _currentTarget = _mapManager->toPseudoCellTransform(_startPosition);
+                if (_state != EAIState::AI_STATE_FRIGHTEND) {
+                    _state = EAIState::AI_STATE_SCATTER;
+                    _events.ScheduleEvent(GHOST_CHANGE_STATE, GHOST_AI_SCATTER_TIME);
+                }
+                _events.ScheduleEvent(GHOST_FIND_TARGET_POINT, 1ms);
+                break;
+            }
+            case GHOST_CHANGE_STATE: {
+                switch (_state) {
+                case EAIState::AI_STATE_CHASE: {
+                    _state = EAIState::AI_STATE_SCATTER;
+                    me->CastSpell(me, SPELL_NPC_CHANGE_STATE_VISUAL);
+                    _events.ScheduleEvent(GHOST_CHANGE_STATE, GHOST_AI_SCATTER_TIME);
+                    break;
+                }
+                case EAIState::AI_STATE_SCATTER: {
+                    _state = EAIState::AI_STATE_CHASE;
+                    me->CastSpell(me, SPELL_NPC_CHANGE_STATE_VISUAL);
+                    _events.ScheduleEvent(GHOST_CHANGE_STATE, GHOST_AI_CHASE_TIME);
+                    break;
+                }
+                case EAIState::AI_STATE_FRIGHTEND: {
+                    _state = EAIState::AI_STATE_SCATTER;
+                    me->SetSpeed(MOVE_RUN, _defautlSpeed);
+                    me->RemoveAurasDueToSpell(SPELL_FEAR_VISUAL);
+                    me->CastSpell(me, SPELL_NPC_CHANGE_STATE_VISUAL);
+                    _events.ScheduleEvent(GHOST_CHANGE_STATE, GHOST_AI_SCATTER_TIME);
+                    break;
+                }
+                default:
+                    break;
+                }
+                _forceChangePath = true;
+                break;
+            }
+            case GHOST_FIND_TARGET_POINT: {
+                DoAction(GHOST_FIND_TARGET_POINT);
+                break;
+            }
+            case GHOST_CHASE_FORCE_RECALCULATE_PATH: {
+                _forceChangePath = true;
+                break;
+            }
+            case GHOST_BACK_TO_START: {
+                me->NearTeleportTo(_startPosition);
+                me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
+                me->RemoveAurasDueToSpell(SPELL_FEAR_VISUAL);
+                me->CastSpell(nullptr, SPELL_STUN_VISUAL);
+                _isFeightDeath = false;
+                me->SetSpeed(MOVE_RUN, _defautlSpeed);
+                _state = EAIState::AI_STATE_SCATTER;
+                _events.ScheduleEvent(GHOST_DELAYED_START, GHOST_RESPAWN_TIME);
+            }
+            default:
+                break;
+        }
+    }
+
+    void GhostAI::PlayerCatched(bool byMe /* = true */)
+    {
+        if (byMe) {
+            me->GetAI()->DoAction(GHOST_WIN);
+        }
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+        me->CastSpell(nullptr, SPELL_SELF_STUN);
+        _events.RescheduleEvent(GHOST_FIND_TARGET_POINT, PLAYER_STUN_DURATION);
+        /* TODO: add some visual effects */
+
+//                         _events.Reset();
+//                         return;
+    }
+
+}// namespace PacMan
diff --git a/src/server/scripts/Custom/GhostAI.h b/src/server/scripts/Custom/GhostAI.h
new file mode 100644
index 0000000000..45f660842a
--- /dev/null
+++ b/src/server/scripts/Custom/GhostAI.h
@@ -0,0 +1,43 @@
+#pragma once
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+#include "PacmanMap.h"
+#include "SpellMgr.h"
+#include "MotionMaster.h"
+
+namespace PacMan {
+    struct GhostAI : public ScriptedAI {
+
+        GhostAI(Creature* creature);
+
+        void InitializeAI() override;
+
+        void Reset() override;
+
+        void OnDespawn() override;
+
+        void DoAction(int32 action) override;
+
+        void UpdateAI(uint32 diff) override;
+
+        void PlayerCatched(bool byMe = true);
+
+    protected:
+        std::unique_ptr<MapManager> _mapManager;
+        std::unique_ptr <PathFinder> _pathFinder;
+
+        PacMan::EAIState _state = EAIState::AI_STATE_SCATTER;
+        Position _startPosition;
+        std::pair<int32_t, int32_t> _currentTarget;
+        std::queue<std::pair<int32_t, int32_t>> _scatterPositions;
+
+        bool _forceChangePath = false;
+        bool _isFeightDeath = false;
+        ObjectGuid _playerGuid;
+        float _defautlSpeed = 0.0f;
+
+        EventMap _events;
+    };
+}
diff --git a/src/server/scripts/Custom/PacmanMap.cpp b/src/server/scripts/Custom/PacmanMap.cpp
new file mode 100644
index 0000000000..1f6749cbc3
--- /dev/null
+++ b/src/server/scripts/Custom/PacmanMap.cpp
@@ -0,0 +1,938 @@
+#include "PacmanMap.h"
+#include "G3D/g3dmath.h"
+#include "GameObjectData.h"
+#include "GameObject.h"
+#include "Object.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "WaypointDefines.h"
+#include <random>
+
+namespace PacMan {
+
+    EventController::EventController() : _running(false)
+    {
+    }
+
+    bool EventController::isRuning() const
+    {
+        return _running;
+    }
+
+    void EventController::prepareEvent(Creature& owner)
+    {
+        if (_running) {
+            return;
+        }
+
+        /* the source of the map can be anything, in this case just constexpr variable */
+        std::string rawMap(TXT_MAP);
+        _mapManager = std::make_unique<MapManager>(std::move(rawMap));
+        _objectFactory = std::make_unique<ObjectFactory>(owner);
+
+
+        /* there is no map validation */
+        if (!_mapManager->parse()) {
+            throw std::runtime_error("Map parsing failed");
+        }
+
+        _pathFinder = std::make_unique<PathFinder>(_mapManager->getGrid());
+
+        _currentMap = owner.GetMap();
+
+        defineTemplates(/*there may be a structure that matches the map cells and templates.*/);
+        _mapManager->calculateArea(POS_MAP);
+    }
+
+    void EventController::defineTemplates()
+    {
+        /* there may be some logic for binding object templates */
+        _objectFactory->defineTemplates();
+    }
+
+    void EventController::summonGameObjects()
+    {
+        if (_running) {
+            return;
+        }
+
+        if (!_mapManager || _mapManager->getGrid().empty() || !_objectFactory) {
+            throw std::runtime_error("MapManager or ObjectFactory is not initialized");
+        }
+
+        int32_t width = _mapManager->getWidth();
+        int32_t height = _mapManager->getHeight();
+
+        for (int32_t i = 0; i < _mapManager->getHeight(); ++i) {
+            for (int32_t j = 0; j < _mapManager->getWidth(); ++j) {
+                STargetPosition pos = _mapManager->getCoordinateInfo({ i, j });
+                if (pos.position == Position{0, 0, 0, 0}) {
+                    continue;
+                }
+                char literal = _mapManager->getGrid()[i][j].first;
+                GameObject* summoned = _objectFactory->summonGameObject(literal, pos);
+                if (summoned) {
+                    _summonedObjects.emplace(summoned->GetGUID(), summoned);
+                }
+                /* else do nothing it is assumed that the cell should be empty. Otherwise, you can add error handling.*/
+            }
+        }
+    }
+
+    void EventController::summonCreatures()
+    {
+        if (_running) {
+            return;
+        }
+
+        if (!_mapManager || _mapManager->getGrid().empty() || !_objectFactory) {
+            throw std::runtime_error("MapManager or ObjectFactory is not initialized");
+        }
+
+        int32_t width = _mapManager->getWidth();
+        int32_t height = _mapManager->getHeight();
+
+        int32_t lifeCounter = 0;
+        int32_t fruitCounter = 0;
+
+        for (int32_t i = 0; i < _mapManager->getHeight(); ++i) {
+            for (int32_t j = 0; j < _mapManager->getWidth(); ++j) {
+                char literal = _mapManager->getGrid()[i][j].first;
+                if (literal == ctFRUIT_POSITION_CELL) {
+                    _fruitPositions.push_back(std::make_pair(i, j));
+                    continue;
+                }
+                if (literal == ctFRUIT_CELL) {
+                    ++fruitCounter;
+                    _fruitsHallOfFame.push(std::make_pair(i, j));
+                    continue;
+                }
+                if (literal == ctPLAYER_START_CELL) {
+                    _playerStartPosition = _mapManager->getCoordinateInfo({ i, j }).position;
+                    _playerStartPosition.SetOrientation(_playerStartPosition.GetOrientation() - M_PI_2);
+                    continue;
+                }
+
+                STargetPosition pos = _mapManager->getCoordinateInfo({ i, j });
+                if (pos.position == Position{ 0, 0, 0, 0 }) {
+                    continue;
+                }
+
+                Creature* summoned = _objectFactory->summonCreature(literal, pos);
+                if (summoned) {
+                    ObjectGuid guid = summoned->GetGUID();
+                    _summonedCreatures.emplace(guid, summoned);
+                    switch (literal) {
+                        case ctBLINKY_START_CELL: {
+                            _blinky = summoned;
+                            break;
+                        }
+                        case ctINKY_START_CELL: {
+                            _inky = summoned;
+                            break;
+                        }
+                        case ctCLYDE_START_CELL: {
+                            _clyde = summoned;
+                            break;
+                        }
+                        case ctPLAYER_LIFE_CELL: {
+                            _lifeCounter.emplace_back(summoned);
+                            ++lifeCounter;
+                            break;
+                        }
+                        case ctBONUS_POINT_CELL:
+                        case ctREGULAR_POINT_CELL: {
+                            ++_points;
+                            [[fallthrough]];
+                        }
+                        default: {
+                            _mapManager->placeCreatureOnGrid(i, j, guid);
+                            break;
+                        }
+                    }
+                }
+                /* else do nothing it is assumed that the cell should be empty. Otherwise, you can add error handling.*/
+            }
+        }
+
+        if (lifeCounter != PACMAN_LIFE_COUNTER || fruitCounter != PACMAN_FRUIT_COUNTER) {
+            throw std::logic_error("Invalid map configuration");
+        }
+
+        _totalPoints = _points;
+    }
+
+    /* in case if i should not manage object life */
+    void EventController::removeCreature(ObjectGuid guid)
+    {
+        auto it = _summonedCreatures.find(guid);
+        if (it != _summonedCreatures.end()) {
+                _summonedCreatures.erase(it);
+        }
+    }
+
+    bool EventController::spawnFruitIfNeeded()
+    {
+        --_points;
+
+        bool needToSpawn = (_points % (_totalPoints / (PACMAN_FRUIT_COUNTER + 1)) == 0) && _points < _totalPoints - 2; // _points < _totalPoints - 2 skip first
+        if (_summonedFruits < PACMAN_FRUIT_COUNTER && needToSpawn) {
+            srand(static_cast<unsigned int>(time(nullptr)));
+            int32_t random = rand() % _fruitPositions.size();
+            auto& fruitPosition = _fruitPositions[random];
+            STargetPosition pos = _mapManager->getCoordinateInfo(fruitPosition);
+            Creature* summoned = _objectFactory->summonCreature(ctFRUIT_POSITION_CELL, pos);
+
+            if (summoned) {
+                _summonedCreatures.emplace(summoned->GetGUID(), summoned);
+                _mapManager->placeCreatureOnGrid(fruitPosition.first, fruitPosition.second, summoned->GetGUID());
+                ++_summonedFruits;
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    void EventController::reset()
+    {
+        _mapManager.release();
+        _objectFactory.release();
+        _pathFinder.release();
+
+        for (auto& object : _summonedObjects) {
+            /*upd: need to check existing creature because access violation if object was removed in-game (gm commands eg)*/
+            GameObject* actualPtr = _currentMap->GetGameObject(object.first);
+            if (actualPtr) {
+                actualPtr->RemoveFromWorld();
+            }
+        }
+        _summonedObjects.clear();
+        for (auto& creature : _summonedCreatures) {
+            Creature* actualPtr = _currentMap->GetCreature(creature.first);
+            if (actualPtr) {
+                actualPtr->RemoveFromWorld();
+            }
+        }
+        _summonedCreatures.clear();
+        _lifeCounter.clear();
+        _fruitPositions.clear();
+        std::stack<std::pair<int32_t, int32_t>> swap;
+        _fruitsHallOfFame.swap(swap);
+
+        _summonedFruits = 0;
+        _points = 0;
+        _totalPoints = 0;
+
+        _blinky = nullptr;
+        _inky = nullptr;
+        _clyde = nullptr;
+
+        _running = false;
+    }
+
+    bool EventController::isEnd() const
+    {
+        return _points == 0;
+    }
+
+    void EventController::run(Player* player)
+    {
+        if (_running || !player) {
+            return;
+        }
+
+        for (auto& model : _lifeCounter) {
+            player->CastSpell(model, SPELL_CLONE_PLAYER, true);
+        }
+
+        _running = true;
+    }
+
+    void EventController::updatePlayerStatus(EventMap& events, ObjectGuid guid)
+    {
+        if (!_running) {
+            return;
+        }
+
+        Player* player = _currentMap->GetPlayer(guid);
+        if (!player || player->GetMapId() != _currentMap->GetId() || !player->IsAlive() || player->isAFK() || player->IsFlying()) {
+            events.ScheduleEvent(STOP_FAIL, 1ms);
+            return;
+        }
+
+        _currentPlayerPosition = player->GetPosition();
+
+        std::pair<int32_t, int32_t> ij = _mapManager->toPseudoCellTransform(_currentPlayerPosition);
+        if (ij.first >= _mapManager->getHeight() || ij.first < 0 ||
+            ij.second >= _mapManager->getWidth() || ij.second < 0) {
+            /* normalize position */
+            ij.first = (ij.first < 0) ? 0 :
+                       (ij.first > _mapManager->getHeight()) ? _mapManager->getHeight() - 1 : ij.first;
+            ij.second = (ij.second < 0) ? 0 :
+                        (ij.second > _mapManager->getWidth()) ? _mapManager->getWidth() - 1 : ij.second;
+
+            Path restoredPlayerPath = _pathFinder->findPath(_previousPlayerPseudoPosition, ij, 4);
+
+            /* jump over teleport case */
+            if (std::find_if(restoredPlayerPath.begin(), restoredPlayerPath.end(), [this, &ij](const std::pair<int32_t, int32_t>& ijIt) {
+                    char mapLiteral = _mapManager->getGrid()[ijIt.first][ijIt.second].first;
+                    if (mapLiteral == ctRIGHT_TP_POINT || mapLiteral == ctLEFT_TP_POINT) {
+                        /* force teleport position as current position */
+                        ij = ijIt;
+                        return true;
+                    }
+                    return false;
+            }) == restoredPlayerPath.end()) {
+                events.ScheduleEvent(STOP_FAIL, 1ms);
+                return;
+            }
+        }
+
+        char mapLiteral = _mapManager->getGrid()[ij.first][ij.second].first;
+        if (mapLiteral == ctRIGHT_TP_POINT) {
+            Position pos = _mapManager->getTeleportTarget(ETeleportTarget::Right);
+            /* there is no solution for pathfinder, but you can add a method that receives a literal by index,
+               or save the teleport points as a field and set it as the previous player position target teleport index */
+            _previousPlayerPseudoPosition = ij;
+            player->NearTeleportTo(pos);
+            /* there should be no interactive objects near the teleport except pursuing monsters */
+            return;
+        }
+        else if (mapLiteral == ctLEFT_TP_POINT) {
+            Position pos = _mapManager->getTeleportTarget(ETeleportTarget::Left);
+            _previousPlayerPseudoPosition = ij;
+            player->NearTeleportTo(pos);
+            return;
+        }
+        else if (mapLiteral == ctPLAYER_START_CELL) {
+            if (_previousPlayerPseudoPosition == std::pair<int32_t, int32_t>{0, 0}) {
+                _previousPlayerPseudoPosition = ij;
+            }
+            return;
+        }
+        else if (mapLiteral == ctWALL_CELL) {
+            movePlayerToStartPosition(player, events);
+            return;
+        }
+
+        /* Workaround - UpdateAI works too slowly to process disappearing monsters. Therefore, we are trying to restore the player's path with dept 4
+           It is possible that due to server delays, the solution will not work as expected..*/
+        Path restoredPlayerPath = _pathFinder->findPath(_previousPlayerPseudoPosition, ij, 4);
+        restoredPlayerPath.emplace_back(ij);
+
+        for (auto& ijIt : restoredPlayerPath) {
+            /* check idle creature on this pseudo-cell */
+            ObjectGuid creatureGuid = _mapManager->getGrid()[ijIt.first][ijIt.second].second;
+
+            if (creatureGuid != ObjectGuid::Empty) {
+                Creature* creature = _currentMap->GetCreature(creatureGuid);
+                if (creature) {
+                    creature->GetAI()->DoAction(CREATURE_TOUCHED_BY_PLAYER);
+                    if (mapLiteral == ctREGULAR_POINT_CELL || mapLiteral == ctBONUS_POINT_CELL || mapLiteral == ctFRUIT_POSITION_CELL) {
+                        _mapManager->placeCreatureOnGrid(ijIt.first, ijIt.second, ObjectGuid::Empty);
+                    }
+                }
+            }
+        }
+
+        _previousPlayerPseudoPosition = ij;
+    }
+
+    void EventController::getPlayerPseudoPosition(int32_t& i, int32_t& j)
+    {
+        std::pair<int32_t, int32_t> ij = _mapManager->toPseudoCellTransform(_currentPlayerPosition);
+        i = ij.first;
+        j = ij.second;
+    }
+
+    int32_t EventController::lifeCheck(Player* player, EventMap& events)
+    {
+        int32_t lifeCounter = PACMAN_LIFE_COUNTER;
+        for (auto it = _lifeCounter.rbegin(); it != _lifeCounter.rend(); ++it) {
+            if (*it != nullptr) {
+                (*it)->KillSelf();
+                (*it)->DespawnOrUnsummon(1000ms);
+                *it = nullptr;
+                movePlayerToStartPosition(player, events);
+                return lifeCounter;
+            }
+            --lifeCounter;
+        }
+
+        return lifeCounter;
+    }
+
+    void EventController::handleFruit(ObjectGuid const& guid)
+    {
+        if (_fruitsHallOfFame.empty()) {
+            /*assert*/
+            return;
+        }
+
+        std::pair<int32_t, int32_t> pos = _fruitsHallOfFame.top();
+        _fruitsHallOfFame.pop();
+
+        Creature* fruit = _currentMap->GetCreature(guid);
+        if (fruit) {
+            std::pair<int32_t, int32_t> savedPos = _mapManager->toPseudoCellTransform(fruit->GetPosition());
+            fruit->NearTeleportTo(_mapManager->getCoordinateInfo(pos).position);
+            fruit->CastSpell(nullptr, SPELL_NPC_TELEPORT_VISUAL);
+            _mapManager->placeCreatureOnGrid(savedPos.first, savedPos.second, guid);
+        }
+    }
+
+    void EventController::movePlayerToStartPosition(Player* player, EventMap& events)
+    {
+        /* dead and start event by same player case */
+        _previousPlayerPseudoPosition = _mapManager->toPseudoCellTransform(_playerStartPosition);
+
+        player->NearTeleportTo(_playerStartPosition, true);
+        player->CastSpell(nullptr, SPELL_STUN_VISUAL);
+        player->CastSpell(nullptr, SPELL_SELF_STUN);
+        events.ScheduleEvent(REMOVE_PLAYER_STUN, PLAYER_STUN_DURATION);
+    }
+
+    void EventController::pingGhosts(EPacmManHandlerAction action)
+    {
+        if (!_running) {
+            return;
+        }
+
+        switch (action) {
+            case EPacmManHandlerAction::BLINKY_LOSE:
+            case EPacmManHandlerAction::BLINKY_WIN: {
+                if (_inky && _clyde) {
+                    _inky->GetAI()->DoAction(action);
+                    _clyde->GetAI()->DoAction(action);
+                }
+                break;
+            }
+            case EPacmManHandlerAction::INKY_LOSE:
+            case EPacmManHandlerAction::INKY_WIN: {
+                if (_blinky && _clyde) {
+                    _clyde->GetAI()->DoAction(action);
+                    _blinky->GetAI()->DoAction(action);
+                }
+                break;
+            }
+            case EPacmManHandlerAction::CLYDE_LOSE:
+            case EPacmManHandlerAction::CLYDE_WIN: {
+                if (_inky && _blinky) {
+                    _inky->GetAI()->DoAction(action);
+                    _blinky->GetAI()->DoAction(action);
+                }
+                break;
+            }
+            case EPacmManHandlerAction::STOP_GHOSTS:
+            case EPacmManHandlerAction::BONUS_POINT_DESPAWN_HA: {
+                if (_inky) {
+                    _inky->GetAI()->DoAction(action);
+                }
+                if (_blinky) {
+                    _blinky->GetAI()->DoAction(action);
+                }
+                if (_clyde) {
+                    _clyde->GetAI()->DoAction(action);
+                }
+                break;
+            }
+            default: {
+                break;
+            }
+        }
+    }
+
+    uint64 EventController::getGhostPosition(EPacmManHandlerAction action) const
+    {
+        switch (action)
+        {
+            case BLINKY: {
+                if (!_blinky) {
+                    return 0;
+                }
+                Position pos = _blinky->GetPosition();
+                std::pair<int32_t, int32_t> ij = _mapManager->toPseudoCellTransform(pos);
+
+                /* check endian */
+                uint16_t num = 0x01;
+                uint8_t* ptr = reinterpret_cast<uint8_t*>(&num);
+                bool isBigEndian = ptr[0] == 0x00;
+
+                uint64 packed = static_cast<uint64_t>(ij.first) << 32 | ij.second;
+                if (isBigEndian) {
+                    /* reverse byte order */
+                    packed = (packed >> 32) | (packed << 32);
+                }
+                return packed;
+            }
+            case INKY:
+            case CLYDE:
+            default:
+                return 0;
+        }
+
+    }
+
+    std::string EventController::getPlayerPosition()
+    {
+        std::pair<int32_t, int32_t> ij = _mapManager->toPseudoCellTransform(_currentPlayerPosition);
+
+        auto r = _pathFinder->findPath(_previousPlayerPseudoPosition, ij, 15);
+        std::string path = "[" + std::to_string(ij.first) + ":" + std::to_string(ij.second) + "]: ";
+        for (auto& ijIt : r) {
+            path += "(" + std::to_string(ijIt.first) + ":" + std::to_string(ijIt.second) + ") ";
+        }
+        return path;
+    }
+
+    MapManager::MapManager(std::string&& textMap) : _rawMap(textMap) {}
+
+    bool MapManager::parse()
+    {
+        std::vector<std::string> rows;
+        size_t startPos = 0;
+        size_t foundPos = _rawMap.find("\n", startPos);
+        while (foundPos != std::string::npos) {
+            rows.emplace_back(_rawMap.substr(startPos, foundPos - startPos));
+            startPos = foundPos + 1;
+            foundPos = _rawMap.find("\n", startPos);
+        }
+        if (startPos < _rawMap.size()) {
+            std::string lastRow = _rawMap.substr(startPos);
+            rows.push_back(lastRow);
+        }
+
+        for (const std::string& row : rows) {
+            std::vector<std::pair<char, ObjectGuid>> map_row;
+            std::for_each(row.begin(), row.end(), [&map_row](char c) { map_row.push_back(std::make_pair(c, ObjectGuid::Empty)); });
+            _grid.push_back(map_row);
+        }
+
+        _mapInfo.width = _grid[0].size();
+        _mapInfo.height = _grid.size();
+
+        return true;
+    }
+
+    void MapManager::calculateArea(const SSquare& square)
+    {
+        /* area size */
+        float width = square.right_top.x - square.left_top.x;
+        float height = square.left_bottom.y - square.left_top.y;
+        float depth_top = square.left_top.z - square.right_top.z;
+        float depth_bottom = square.left_bottom.z - square.right_bottom.z;
+
+        /* one square size */
+        float square_width = width / _mapInfo.width;
+        float square_height = height / _mapInfo.height;
+        _mapInfo.square_height = square_height; _mapInfo.square_width = square_width;
+
+        /* rectangle rotation angle */
+        float angle = static_cast<float>(G3D::aTan2(square.left_top.y - square.right_top.y, square.left_top.x - square.right_top.x));
+        _mapInfo.angle = angle;
+
+        float delta_x = square.left_top.x;
+        float delta_y = square.left_top.y;
+        _mapInfo.delta_x = delta_x; _mapInfo.delta_y = delta_y;
+
+        for (int32_t i = 0; i < _mapInfo.height; ++i) {
+            for (int32_t j = 0; j < _mapInfo.width; ++j) {
+
+                /* find the center of the current square */
+                float center_x = j * square_width + square_width / 2;
+                float center_y = i * square_height + square_height / 2;
+
+                /* APPROXIMATE Interpolation factor to determine the Z value in a given square */
+                float interpolation_coefficient_x = center_x / width;
+                float z_top = square.left_top.z + (square.right_top.z - square.left_top.z) * interpolation_coefficient_x;
+                float z_bottom = square.left_bottom.z + (square.right_bottom.z - square.left_bottom.z) * interpolation_coefficient_x;
+
+                /* Correcting coordinates taking into account displacement and rotation */
+                float rotated_x = center_x * cos(angle) - center_y * sin(angle);
+                float rotated_y = center_x * sin(angle) + center_y * cos(angle);
+
+                float final_x = delta_x - rotated_x;
+                float final_y = delta_y - rotated_y;
+                float interpolation_coefficient_y = center_y / height;
+                float final_z = z_top - (z_top - z_bottom) * interpolation_coefficient_y;
+
+                std::pair<int32_t, int32_t> ij = { i, j };
+                QuaternionData quanterion = QuaternionData::fromEulerAnglesZYX(angle, 0, 0);;
+                Position position = { final_x, final_y, final_z, angle };
+                STargetPosition pos = { quanterion, position };
+                setCoordinateInfo(ij, std::move(pos));
+            }
+        }
+    }
+
+    int32_t MapManager::getWidth() const
+    {
+        return _mapInfo.width;
+    }
+
+    int32_t MapManager::getHeight() const
+    {
+        return _mapInfo.height;
+    }
+
+    const Map& MapManager::getGrid() const
+    {
+        return _grid;
+    }
+
+    char MapManager::getGridCell(int32_t i, int32_t j) const
+    {
+        if (i < 0 || i >= _mapInfo.height || j < 0 || j >= _mapInfo.width) {
+            return '0';
+        }
+        return _grid[i][j].first;
+    }
+
+    void MapManager::placeCreatureOnGrid(int32_t i, int32_t j, ObjectGuid guid)
+    {
+        if (i < 0 || i >= _mapInfo.height || j < 0 || j >= _mapInfo.width) {
+            return;
+        }
+        _grid[i][j].second = guid;
+    }
+
+    void MapManager::setCoordinateInfo(std::pair<int32_t, int32_t>& ij, STargetPosition&& pos)
+    {
+        _worldCoordinates[ij] = pos;
+        if (_grid[ij.first][ij.second].first == ctLEFT_TP_TARGET) {
+            _leftTeleportTarget = pos.position;
+            _leftTeleportTarget.SetOrientation(_mapInfo.angle);
+        }
+        else if (_grid[ij.first][ij.second].first == ctRIGHT_TP_TARGET) {
+            _rightTeleportTarget = pos.position;
+            _rightTeleportTarget.SetOrientation(_mapInfo.angle + M_PI);
+        }
+    }
+
+    PacMan::STargetPosition MapManager::getCoordinateInfo(const std::pair<int32_t, int32_t>& ij)
+    {
+        auto it = _worldCoordinates.find(ij);
+        if (it == _worldCoordinates.end()) {
+            return STargetPosition{};
+        }
+        return it->second;
+    }
+
+    void MapManager::setMapInfo(SMapInfo&& mapInfo)
+    {
+        _mapInfo = mapInfo;
+    }
+
+    std::pair<int32_t, int32_t> MapManager::toPseudoCellTransform(Position& worldPosition)
+    {
+        int32_t i, j;
+        j = static_cast<int32_t>(((_mapInfo.delta_x - worldPosition.GetPositionX()) * cos(_mapInfo.angle) +
+                                 (_mapInfo.delta_y - worldPosition.GetPositionY()) * sin(_mapInfo.angle)) / _mapInfo.square_width);
+        i = static_cast<int32_t>((-(_mapInfo.delta_x - worldPosition.GetPositionX()) * sin(_mapInfo.angle) +
+                                 (_mapInfo.delta_y - worldPosition.GetPositionY()) * cos(_mapInfo.angle)) / _mapInfo.square_height);
+        return { i, j };
+    }
+
+    std::pair<int32_t, int32_t> MapManager::toPseudoCellTransform(const Position& worldPosition)
+    {
+        int32_t i, j;
+        j = static_cast<int32_t>(((_mapInfo.delta_x - worldPosition.GetPositionX()) * cos(_mapInfo.angle) +
+            (_mapInfo.delta_y - worldPosition.GetPositionY()) * sin(_mapInfo.angle)) / _mapInfo.square_width);
+        i = static_cast<int32_t>((-(_mapInfo.delta_x - worldPosition.GetPositionX()) * sin(_mapInfo.angle) +
+            (_mapInfo.delta_y - worldPosition.GetPositionY()) * cos(_mapInfo.angle)) / _mapInfo.square_height);
+        return { i, j };
+    }
+
+    const Position& MapManager::getTeleportTarget(ETeleportTarget target)
+    {
+        switch (target)
+        {
+        case PacMan::ETeleportTarget::Left:
+            return _leftTeleportTarget;
+        case PacMan::ETeleportTarget::Right:
+            return _rightTeleportTarget;
+        default:
+            /* Should not happen. Just in case, so as not to create an extra default value and not return empty */
+            return _leftTeleportTarget;
+        }
+    }
+
+    const PacMan::SMapInfo& MapManager::getMapInfo() const
+    {
+        return _mapInfo;
+    }
+
+    bool MapManager::isAccessible(int32_t i, int32_t j) const
+    {
+        return isAccessible(_grid[i][j].first);
+    }
+
+    bool MapManager::isAccessible(char point) const
+    {
+        return (point == ctEMPTY_CELL || point == ctREGULAR_POINT_CELL || point == ctBONUS_POINT_CELL ||
+                point == ctPLAYER_START_CELL || point == ctBLINKY_START_CELL || point == ctLEFT_TP_TARGET ||
+                point == ctRIGHT_TP_TARGET || point == ctFRUIT_POSITION_CELL);
+    }
+
+    bool MapManager::isValidRange(int32_t i, int32_t j) const
+    {
+        return (i >= 0 && i < _mapInfo.height && j >= 0 && j < _mapInfo.width);
+    }
+
+    std::pair<int32_t, int32_t> MapManager::getRandomNearPoint(int32_t centerI, int32_t centerJ) const
+    {
+        std::random_device rd;
+        std::mt19937 gen(rd());
+
+        int32_t startJ = std::max(0, centerJ - _mapInfo.width / 2);
+        int32_t endJ = std::min(_mapInfo.width - 1, centerJ + _mapInfo.width / 2);
+        int32_t startI = std::max(0, centerI - _mapInfo.height / 2);
+        int32_t endI = std::min(_mapInfo.height - 1, centerI + _mapInfo.height / 2);
+
+        std::uniform_int_distribution<int32_t> distribJ(startJ, endJ);
+        std::uniform_int_distribution<int32_t> distribI(startI, endI);
+
+        int32_t randomJ = distribJ(gen);
+        int32_t randomI = distribI(gen);
+
+        while (!isAccessible(_grid[randomI][randomJ].first)) {
+            randomJ = distribJ(gen);
+            randomI = distribI(gen);
+        }
+
+        return std::make_pair(randomI, randomJ);
+    }
+
+    std::pair<int32_t, int32_t> MapManager::getRandomNearPointEx(int32_t centerI, int32_t centerJ) const
+    {
+        std::vector<std::pair<int32_t, int32_t>> accessiblePoints;
+
+        int32_t startJ = std::max(0, centerJ - _mapInfo.width / 2);
+        int32_t endJ = std::min(_mapInfo.width - 1, centerJ + _mapInfo.width / 2);
+        int32_t startI = std::max(0, centerI - _mapInfo.height / 2);
+        int32_t endI = std::min(_mapInfo.height - 1, centerI + _mapInfo.height / 2);
+
+        for (int32_t i = startI; i <= endI; ++i) {
+            for (int32_t j = startJ; j <= endJ; ++j) {
+                if (isAccessible(_grid[i][j].first)) {
+                    accessiblePoints.push_back(std::make_pair(i, j));
+                }
+            }
+        }
+
+        std::random_device rd;
+        std::mt19937 gen(rd());
+        std::uniform_int_distribution<int32_t> distrib(0, accessiblePoints.size() - 1);
+        return accessiblePoints[distrib(gen)];
+    }
+
+    std::pair<int32_t, int32_t> MapManager::getNearestAvailablePoint(const std::pair<int32_t, int32_t>& target)
+    {
+        std::vector<std::vector<bool>> visited(_mapInfo.height, std::vector<bool>(_mapInfo.width, false));
+
+        std::queue<std::pair<int32_t, int32_t>> q;
+        q.push(target);
+        visited[target.first][target.second] = true;
+
+        int dj[] = { 0, 0, 1, -1 };
+        int di[] = { 1, -1, 0, 0 };
+
+        while (!q.empty()) {
+            std::pair<int32_t, int32_t> current = q.front();
+            q.pop();
+
+            for (int k = 0; k < 4; ++k) {
+                int newI = current.first + di[k];
+                int newJ = current.second + dj[k];
+
+                if (isValidRange(newI, newJ) && !visited[newI][newJ]) {
+                    visited[newI][newJ] = true;
+
+                    if (isAccessible(newI, newJ)) {
+                        return { newI, newJ };
+                    }
+
+                    q.push({ newI, newJ });
+                }
+            }
+        }
+
+        return target;
+    }
+
+    std::vector<Position> MapManager::toWaypointPathTransform(const Path& path)
+    {
+        std::vector<Position> result;
+
+        /*int32_t id = _lastWaypointId;*/
+        for (const auto& point : path) {
+            if (_waypointsCache[point].m_positionX == 0) {
+                Position pos = getCoordinateInfo(point).position;
+                /*WaypointNode newNode(id++, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ());*/
+                _waypointsCache[point] = std::move(pos);
+            }
+
+            result.push_back(_waypointsCache[point]);
+        }
+
+        /* i will no reuse WayPointPath i think */
+        /*return WaypointPath(id, std::move(result));*/
+        return result;
+    }
+
+    ObjectFactory::ObjectFactory(Creature& owner) : _owner(owner), _objectTemplate{} {}
+
+    void ObjectFactory::defineTemplates()
+    {
+        _objectTemplate['X'] = { 188236, EObjectType::GameObject }; // box
+        _objectTemplate['1'] = { 43501, EObjectType::Creature }; // regular point
+        _objectTemplate['2'] = { 43505, EObjectType::Creature }; // bonus point
+        _objectTemplate['B'] = { 43502, EObjectType::Creature }; // Blinky
+        _objectTemplate['I'] = { 43503, EObjectType::Creature }; // Inky
+        _objectTemplate['c'] = { 43504, EObjectType::Creature }; // Clyde
+        _objectTemplate['P'] = { 43506, EObjectType::Creature }; // life counter
+        _objectTemplate['3'] = { 43507, EObjectType::Creature }; // fruit
+    }
+
+    GameObject* ObjectFactory::summonGameObject(const char literal, const STargetPosition& positionInfo)
+    {
+        auto templateIt = _objectTemplate.find(literal);
+        if (templateIt == _objectTemplate.end() || templateIt->second.objectType != EObjectType::GameObject) {
+            return nullptr;
+        }
+
+        uint32 entry = templateIt->second.entry;
+        GameObject* gameObject = _owner.SummonGameObject(entry, positionInfo.position, positionInfo.quanterion, Seconds(0));
+        if (!gameObject) {
+            return nullptr;
+        }
+        gameObject->SetOwnerGUID(_owner.GetGUID());
+        return gameObject;
+    }
+
+    Creature* ObjectFactory::summonCreature(const char literal, const STargetPosition& positionInfo)
+    {
+        auto templateIt = _objectTemplate.find(literal);
+        if (templateIt == _objectTemplate.end() || templateIt->second.objectType != EObjectType::Creature) {
+            return nullptr;
+        }
+
+        uint32 entry = templateIt->second.entry;
+        Position position = positionInfo.position;
+        position.SetOrientation(position.GetOrientation() - M_PI_2);
+        Creature* creature = _owner.SummonCreature(entry, position);
+        if (!creature) {
+            return nullptr;
+        }
+        creature->SetOwnerGUID(_owner.GetGUID());
+        return creature;
+    }
+
+    PathFinder::PathFinder(const Map& grid) : _grid(grid), _width(grid[0].size()), _height(grid.size()) {}
+
+    Path PathFinder::findPath(std::pair<int32_t, int32_t> start, std::pair<int32_t, int32_t> end, int32_t depth) {
+        std::vector<std::pair<int32_t, int32_t>> directions = { {-1, 0}, {0, -1}, {1, 0}, {0, 1} };
+
+        std::vector<std::vector<bool>> closedSet(_height, std::vector<bool>(_width, false));
+        std::vector<std::vector<Node>> nodes(_height, std::vector<Node>(_width));
+
+        Node* startNode = &nodes[start.first][start.second];
+        *startNode = Node(start.first, start.second, 0, std::abs(end.first - start.first) + std::abs(end.second - start.second), nullptr);
+
+        int32_t depthCounter = 0;
+
+        while (depthCounter <= depth) {
+            Node* currentNode = nullptr;
+            int32_t minCost = INT_MAX;
+
+            for (int32_t i = 0; i < _height; ++i) {
+                for (int32_t j = 0; j < _width; ++j) {
+                    if (!closedSet[i][j] && nodes[i][j].g + nodes[i][j].h < minCost) {
+                        currentNode = &nodes[i][j];
+                        minCost = currentNode->g + currentNode->h;
+                    }
+                }
+            }
+
+            if (currentNode == nullptr) break;
+
+            int32_t x = currentNode->x;
+            int32_t y = currentNode->y;
+
+            if (x == end.first && y == end.second) {
+                Path path;
+                while (currentNode != nullptr) {
+                    path.emplace_back(currentNode->x, currentNode->y);
+                    currentNode = currentNode->parent;
+                }
+                std::reverse(path.begin(), path.end());
+                return path;
+            }
+
+            closedSet[x][y] = true;
+
+            for (const auto& dir : directions) {
+                int32_t newX = x + dir.first;
+                int32_t newY = y + dir.second;
+
+                if (isValid(newX, newY, _height, _width) && !closedSet[newX][newY]) {
+                    int32_t g = currentNode->g + 1;
+                    int32_t h = std::abs(end.first - newX) + std::abs(end.second - newY);
+                    if (g + h < nodes[newX][newY].g + nodes[newX][newY].h || nodes[newX][newY].g + nodes[newX][newY].h == 0) {
+                        nodes[newX][newY] = Node(newX, newY, g, h, currentNode);
+                    }
+                }
+            }
+
+            depthCounter++;
+        }
+
+        int32_t minDistance = INT_MAX;
+        Node* closestNode = nullptr;
+
+        for (int32_t i = 0; i < _height; ++i) {
+            for (int32_t j = 0; j < _width; ++j) {
+                if (closedSet[i][j]) {
+                    int32_t distance = std::abs(end.first - i) + std::abs(end.second - j);
+                    if (distance < minDistance) {
+                        minDistance = distance;
+                        closestNode = &nodes[i][j];
+                    }
+                }
+            }
+        }
+
+        Path path;
+        while (closestNode != nullptr) {
+            path.emplace_back(closestNode->x, closestNode->y);
+            closestNode = closestNode->parent;
+        }
+        std::reverse(path.begin(), path.end());
+
+        return path;
+    }
+
+    bool PathFinder::isAdjacent(const std::pair<int32_t, int32_t>& current, const std::pair<int32_t, int32_t>& target)
+    {
+        int dj = std::abs(current.second - target.second);
+        int di = std::abs(current.first - target.first);
+
+        return (dj <= 1 && di <= 1) || current == target;
+    }
+
+    std::string sprintf(const char* fmt, ...)
+    {
+        va_list ap;
+        va_start(ap, fmt);
+
+        const int bufferSize = 256;
+        char buffer[bufferSize];
+
+        vsnprintf(buffer, bufferSize, fmt, ap);
+        va_end(ap);
+
+        return std::string(buffer);
+    }
+
+} // namespace PacMan
diff --git a/src/server/scripts/Custom/PacmanMap.h b/src/server/scripts/Custom/PacmanMap.h
new file mode 100644
index 0000000000..525f15c837
--- /dev/null
+++ b/src/server/scripts/Custom/PacmanMap.h
@@ -0,0 +1,499 @@
+#pragma once
+#include "Define.h"
+#include "GameObjectData.h"
+
+namespace PacMan {
+    static constexpr uint32 AT_PLAYER_START = 6000;
+    static constexpr uint32 AT_NPC_VANTAGE = 6001;
+
+    static constexpr uint32 PC_GOSSIP_STOP_EVENT = 1;
+    static constexpr uint32 PC_GOSSIP_SET_DEADLINE = 2;
+    static constexpr uint32 PC_GOSSIP_DEBUG_IDLE_GHOSTS = 3;
+    static constexpr uint32 PC_GOSSIP_DUMMY = 100;
+
+    static constexpr Milliseconds EVENT_DEADLINE = 240s;
+
+    static constexpr Milliseconds PLAYER_STUN_DURATION = 5100ms;
+    static constexpr Milliseconds EVENT_AURA_STACK_SPEED = 25s; // the duration of the aura is 30 seconds
+    static constexpr Milliseconds GHOST_AI_SCATTER_TIME = 7s;  // pac-man original 7 seconds
+    static constexpr Milliseconds GHOST_AI_CHASE_TIME = 15s;  // pac-man original 20 seconds
+    static constexpr Milliseconds GHOST_AI_FRIGHTENED_TIME = 10s;
+    static constexpr Milliseconds BLINKY_AI_DELAYED_START = 5s;
+    static constexpr Milliseconds FRUIT_LIFETIME = 15s;
+
+    static constexpr Milliseconds GHOST_CORPSE_TELEPORT_TIME = 1500ms;
+    static constexpr Milliseconds GHOST_RESPAWN_TIME = 5s;
+
+    static constexpr int32_t CLYDE_AI_CHASE_DISTANCE = 8;
+
+    /* used if ghosts start by timer */
+    static constexpr Milliseconds INKY_AI_DELAYED_START = 10s;
+    static constexpr Milliseconds CLYDE_AI_DELAYED_START = 15s;
+    static constexpr bool GHOSTS_START_BY_TIMER = true;
+
+    /* scatter positions */
+    static constexpr std::pair<int32_t, int32_t> BLINKY_SCATTER_POS1 = { 1, 21 };
+    static constexpr std::pair<int32_t, int32_t> BLINKY_SCATTER_POS2 = { 4, 20 };
+    static constexpr std::pair<int32_t, int32_t> BLINKY_SCATTER_POS3 = { 2, 17 };
+
+    static constexpr std::pair<int32_t, int32_t> INKY_SCATTER_POS1 = { 23, 21 };
+    static constexpr std::pair<int32_t, int32_t> INKY_SCATTER_POS2 = { 18, 17 };
+    static constexpr std::pair<int32_t, int32_t> INKY_SCATTER_POS3 = { 22, 12 };
+
+    static constexpr std::pair<int32_t, int32_t> CLYDE_SCATTER_POS1 = { 23, 1 };
+    static constexpr std::pair<int32_t, int32_t> CLYDE_SCATTER_POS2 = { 18, 5 };
+    static constexpr std::pair<int32_t, int32_t> CLYDE_SCATTER_POS3 = { 22, 10 };
+
+    /* scores define */
+    static constexpr uint32_t SCORE_REGULAR_POINT = 10;
+    static constexpr uint32_t SCORE_POWER_POINT = 50;
+    static constexpr uint32_t SCORE_FRUIT_POINT = 100;
+    static constexpr uint32_t SCORE_GHOST_EATEN = 200;
+
+
+    /* ghost phrases */
+    static const char* GHOSTS_SAYS_WHEN_ANOTHER_ONE_IS_EATEN[10] = {
+        "Oh no! %s got caught!",
+        "Looks like %s was too slow!",
+        "%s, you fell for it!",
+        "Stay sharp, %s!",
+        "Careful next time, %s!",
+        "Keep an eye out, %s!",
+        "You'll get 'em next time, %s!",
+        "Almost had 'em, %s!",
+        "%s, better luck next round!",
+        "He is too fast for us, %s!"
+    };
+
+    static const char* GHOSTS_SAYS_WHEN_ANOTHER_ONE_CATCH_PLAYER[10] = {
+        "Wow, %s got one!",
+        "%s caught a snack!",
+        "Nice catch, %s!",
+        "Great job, %s!",
+        "%s got 'em!",
+        "Way to go, %s!",
+        "Good move, %s!",
+        "That's how it's done, %s!",
+        "Impressive, %s!",
+        "You got 'em, %s!"
+    };
+
+    static const char* GHOST_SAYS_WHEN_WAS_EATEN[10] = {
+        "Nice one, %s! But I'll be back!",
+        "You got lucky, %s! Watch your back!",
+        "Good move, %s! But I'll get you next time!",
+        "You're fast, %s! But I'll catch up!",
+        "You're good, %s! But I'm not done yet!",
+        "Impressive, %s! But I'll haunt you again!",
+        "You're quick, %s! But I'll return!",
+        "Well played, %s! But I'll be waiting!",
+        "Great job, %s! But I'll catch you later!",
+        "You won this round, %s! But I'll be back for more!"
+    };
+
+    static const char* GHOST_SAY_WHEN_WAS_FRIGHTENED[10] = {
+        "Ahh! %s is scary!",
+        "I'm outta here! %s is scary!",
+        "I'm not sticking around! %s is scary!",
+        "I'm not waiting around! %s is scary!",
+        "Ahh! %s is chilling!",
+        "I'm outta here! %s is spine-tingling!",
+        "I'm not lingering! %s is bone-chilling!",
+        "I'm not pausing! %s is hair-raising!",
+        "I'm not loitering! %s is giving me goosebumps!",
+        "I'm not stopping! %s is eerie!"
+    };
+
+//     static constexpr uint32 AT_LEFT_TP_POINT = 6002;
+//     static constexpr uint32 AT_RIGHT_TP_POINT = 6003;
+
+/* The map can be loaded in any other way and can be binary for optimal calculations, but for example it is hardcoded and human readable */
+    constexpr const char* TXT_MAP =
+R"(XXXXXXXXXXXXXXXXXXXXXXX
+X1111111111X1111111111X
+X1XXX1XXXX1X1XXXX1XXX1X
+X2XXX1XXXX1X1XXXX1XXX2X
+X111111111111111111111X
+X1XXX1X1XXXXXXX1X1XXX1X
+X11111X1XXXXXXX1X11111X
+XXXXX1X1111X1111X1XXXXX
+xxxxX1XXXX0X0XXXX1Xxxxx
+xxxxX1X3333B3333X1Xxxxx
+XXXXX1X3XXX0XXX3X1XXXXX
+LLr00103X0I0c0X30100lRR
+XXXXX1X3XXXXXXX3X1XXXXX
+xxxxX1X333333333X1Xxxxx
+xxxxX1X0XXXXXXX0X1Xxxxx
+XXXXX1X0XXXXXXX0X1XXXXX
+X1111111111X1111111111X
+X1XXX1XXXX1X1XXXX1XXX1X
+X211X111111C111111X112X
+XXX1X1X1XXXXXXX1X1X1XXX
+X11111X1111X1111X11111X
+X1XXXXXXXX1X1XXXXXXXX1X
+X1XXXXXXXX1X1XXXXXXXX1X
+X111111111111111111111X
+XXXXXXXXXXXXXXXXXXXXXXX
+xxxxxxxxxxxxxxxxxxxxxxx
+xPxPxPxxxxxxxxxxxxxFxFx)";
+
+/* must match the quantity on the map*/
+static constexpr uint32_t PACMAN_FRUIT_COUNTER = 2;
+static constexpr uint32_t PACMAN_LIFE_COUNTER = 3;
+
+// X - wall
+// x - unaccessible empty cell
+// 0 - empty cell
+// C - player start position
+// B, I, c - Blinky, Inky, Clyde start position
+// L - left teleport point
+// R - right teleport point
+// l - left teleport target
+// r - right teleport target
+// P - player life counter
+// F - eaten fruits counter
+// 3 - possible fruit position
+
+    /* simple structure instead class Position */
+    struct SSquare {
+        struct SPosition {
+            float x;
+            float y;
+            float z;
+        };
+
+        SPosition left_top;
+        SPosition right_top;
+        SPosition right_bottom;
+        SPosition left_bottom;
+    };
+
+    struct STargetPosition {
+        QuaternionData quanterion;
+        Position position;
+    };
+
+    static constexpr SSquare POS_MAP = {
+        {7060.105957f, 4380.169922f, 872.062866f},
+        {7111.892090f, 4367.100098f, 872.333069f},
+        {7098.489258f, 4313.977051f, 871.325684f},
+        {7046.707031f, 4327.068848f, 871.056946f}
+    };
+
+    enum ECellTemplate : char
+    {
+        ctEMPTY_CELL = '0',
+        ctWALL_CELL = 'X',
+        ctUNACCESSIBLE_CELL = 'x',
+        ctREGULAR_POINT_CELL = '1',
+        ctBONUS_POINT_CELL = '2',
+        ctPLAYER_START_CELL = 'C',
+        ctMONSTER_START_CELL = 'M',
+        ctLEFT_TP_POINT = 'L',
+        ctRIGHT_TP_POINT = 'R',
+        ctLEFT_TP_TARGET = 'l',
+        ctRIGHT_TP_TARGET = 'r',
+        ctBLINKY_START_CELL = 'B',
+        ctINKY_START_CELL = 'I',
+        ctCLYDE_START_CELL = 'c',
+        ctPLAYER_LIFE_CELL = 'P',
+        ctFRUIT_CELL = 'F',
+        ctFRUIT_POSITION_CELL = '3'
+    };
+
+    enum class EObjectType : int32 {
+        Unknown = -1,
+        Creature = 0,
+        GameObject = 1
+    };
+
+    enum EPacmManHandlerAction : uint16 {
+        CHECK_PLAYER_POSITION = 1,
+        SHOW_TELEPORT_VISUAL = 2,
+        REMOVE_PLAYER_STUN = 3,
+        RENEW_EVENT_AURA_DAMAGE = 4,
+        RENEW_EVENT_AURA = 5,
+        REMOVE_SPHERE_VISUAL = 6,
+        MOVE_FRUIT = 7,
+        STOP_GHOSTS = 8,
+
+        BONUS_POINT_DESPAWN_HA = 9,
+
+        BLINKY_WIN = 50,
+        INKY_WIN = 51,
+        CLYDE_WIN = 52,
+        BLINKY_LOSE = 53,
+        INKY_LOSE = 54,
+        CLYDE_LOSE = 55,
+        BLINKY = 56,
+        INKY = 57,
+        CLYDE = 58,
+        GHOST_WIN = 59,
+        GHOST_LOSE = 60,
+
+        PLAYER_STARTED = 98,
+        TELEPORT_PLAYER_AT_START = 99,
+        STOP_FAIL = 100,
+        STOP_SUCCESS = 101,
+    };
+
+    enum ECreatureAction : int32 {
+        REGULAR_POINT_DESPAWN = 1,
+        CREATURE_TOUCHED_BY_PLAYER = 2,
+        REGULAR_POINT_TOUCHED_BY_PLAYER = 2,
+        GHOST_DELAYED_START = 3,
+        GHOST_FIND_TARGET_POINT = 4,
+        GHOST_CHANGE_STATE = 5,
+        GHOST_CHASE_FORCE_RECALCULATE_PATH = 6,
+        GHOST_BACK_TO_START = 7,
+        GHOST_RESPAWN = 8,
+        BONUS_POINT_DESPAWN = 9,
+        FRUIT_DESPAWN = 10,
+
+        GET_BLINKY_POSITION = 100,
+
+        GET_CURRENT_PLAYER = 1000,
+    };
+
+    enum class ETeleportTarget : int32 {
+        Left = 0,
+        Right = 1
+    };
+
+    enum ESpeells : uint32 {
+        SPELL_NPC_TELEPORT_VISUAL = 73078,
+        SPELL_STUN_VISUAL = 18970,
+        SPELL_SELF_STUN = 80000,//48342,
+        SPELL_PLAYER_TELEPORT_VISUAL = 70088,
+        SPELL_EVENT_AURA = 80001,
+        SPELL_EVENT_AURA_DAMAGE = 80003,
+        SPELL_EVENT_AURA_DECREASE_SPEED = 80004,
+        SPELL_NPC_CHANGE_STATE_VISUAL = 75459,
+        SPELL_FEAR_VISUAL = 49774,
+        SPELL_FEIGN_DEATH = 37493,
+        SPELL_SPHERE_VISUAL = 56075,
+        SPELL_CLONE_PLAYER = 45204
+    };
+
+    enum class EAIState : uint32 {
+        AI_STATE_CHASE = 0,
+        AI_STATE_SCATTER = 1,
+        AI_STATE_FRIGHTEND = 2,
+    };
+
+    using Map = std::vector<std::vector<std::pair<char, ObjectGuid>>>;
+    using WorldCoordinates = std::unordered_map<std::pair<int32_t, int32_t>, STargetPosition>;
+    using PseudoCoordinates = std::unordered_map<Position, std::pair<int32_t, int32_t>>;
+    using Path = std::vector<std::pair<int32_t, int32_t>>;
+
+    struct SMapInfo {
+        int32_t width = 0;
+        int32_t height = 0;
+        float angle = 0;
+        float delta_x = 0;
+        float delta_y = 0;
+        float square_width = 0;
+        float square_height = 0;
+    };
+
+    std::string sprintf(const char* fmt, ...);
+
+    class MapManager
+    {
+        /*friend class EventController;*/
+
+        public:
+            MapManager()  = delete;
+
+            MapManager(std::string&& textMap);
+            ~MapManager() = default;
+            MapManager(const MapManager&) = default;
+            MapManager& operator=(const MapManager&) = default;
+            MapManager(MapManager&&) = default;
+            MapManager& operator=(MapManager&&) = default;
+
+            bool parse();
+            void calculateArea(const SSquare& square);
+            int32_t getWidth() const;
+            int32_t getHeight() const;
+            const Map& getGrid() const;
+            char getGridCell(int32_t i, int32_t j) const;
+            void placeCreatureOnGrid(int32_t i, int32_t j, ObjectGuid guid);
+            void setCoordinateInfo(std::pair<int32_t, int32_t>& ij, STargetPosition&& pos);
+            STargetPosition getCoordinateInfo(const std::pair<int32_t, int32_t>& ij);
+            void setMapInfo(SMapInfo&& mapInfo);
+            std::pair<int32_t, int32_t> toPseudoCellTransform(Position& worldPosition);
+            std::pair<int32_t, int32_t> toPseudoCellTransform(const Position& worldPosition);
+            const Position& getTeleportTarget(ETeleportTarget target);
+            const SMapInfo& getMapInfo() const;
+
+            bool isAccessible(int32_t i, int32_t j) const;
+            bool isAccessible(char point) const;
+            bool isValidRange(int32_t i, int32_t j) const;
+            /* generates a random point until it hits an available one. */
+            std::pair<int32_t, int32_t> getRandomNearPoint(int32_t centerI, int32_t centerJ) const;
+            /* calculates all available points and selects a random one. I don't know which solution is better */
+            std::pair<int32_t, int32_t> getRandomNearPointEx(int32_t centerI, int32_t centerJ) const;
+            std::pair<int32_t, int32_t> getNearestAvailablePoint(const std::pair<int32_t, int32_t>& target);
+            std::vector<Position> toWaypointPathTransform(const Path& path);
+
+        private:
+
+            struct IntPairHash {
+                size_t operator()(const std::pair<int32_t, int32_t>& p) const {
+                    size_t h1 = std::hash<int32_t>{}(p.first);
+                    size_t h2 = std::hash<int32_t>{}(p.second);
+                    return h1 ^ (h2 << 1);
+                }
+            };
+
+            std::string _rawMap;
+            Map _grid;
+            WorldCoordinates _worldCoordinates;
+//            PseudoCoordinates _pseudoCoordinates;
+            SMapInfo _mapInfo;
+
+            Position _leftTeleportTarget;
+            Position _rightTeleportTarget;
+
+/*            std::unordered_map<std::pair<int32_t, int32_t>, WaypointNode, IntPairHash> _waypointsCache;*/
+            std::unordered_map<std::pair<int32_t, int32_t>, Position, IntPairHash> _waypointsCache;
+            /*int32_t _lastWaypointId = 10000000;*/
+    };
+
+    class ObjectFactory {
+
+            struct SObjectTemplate {
+                uint32 entry = 0;
+                EObjectType objectType = EObjectType::Unknown;
+            };
+
+        public:
+            ObjectFactory()  = delete;
+
+            ObjectFactory(Creature& owner);
+            ~ObjectFactory() = default;
+            ObjectFactory(const ObjectFactory&) = default;
+            ObjectFactory& operator=(const ObjectFactory&) = default;
+            ObjectFactory(ObjectFactory&&) = default;
+            ObjectFactory& operator=(ObjectFactory&&) = default;
+
+            void defineTemplates();
+            GameObject* summonGameObject(const char literal, const STargetPosition& positionInfo);
+            Creature* summonCreature(const char literal, const STargetPosition& positionInfo);
+
+        private:
+            Creature& _owner;
+            std::map<char, SObjectTemplate> _objectTemplate;
+
+
+    };
+
+    class PathFinder {
+        public:
+            PathFinder()  = delete;
+
+            PathFinder(const Map& grid);
+            ~PathFinder() = default;
+
+
+            Path findPath(std::pair<int32_t, int32_t> start, std::pair<int32_t, int32_t> end, int32_t depth);
+            bool isAdjacent(const std::pair<int32_t, int32_t>& current, const std::pair<int32_t, int32_t>& target);
+
+        private:
+            struct Node {
+                Node(int32_t x, int32_t y, int32_t g, int32_t h, Node* parent = nullptr)
+                    : x(x), y(y), g(g), h(h), parent(parent) {}
+                Node() = default;
+
+                int32_t f() const {
+                    return g + h;
+                }
+
+                int32_t x = 0, y = 0;
+                int32_t g = 2048, h = 2048;
+                Node* parent = nullptr;
+            };
+            struct CompareNode {
+                bool operator()(const std::unique_ptr<Node>& a, const std::unique_ptr<Node>& b) const {
+                    return a->f() > b->f();
+                }
+            };
+
+            bool isValid(int32_t x, int32_t y, int32_t rows, int32_t cols) {
+                return x >= 0 && x < rows && y >= 0 && y < cols && _grid[x][y].first != ctWALL_CELL;
+            }
+
+            const Map& _grid;
+            const int32_t _width;
+            const int32_t _height;
+    };
+
+    class EventController {
+    public:
+        EventController();
+        ~EventController() = default;
+        EventController(const EventController&) = default;
+        EventController& operator=(const EventController&) = default;
+        EventController(EventController&&) = default;
+        EventController& operator=(EventController&&) = default;
+
+        bool isRuning() const;
+        void prepareEvent(Creature& owner);
+        void defineTemplates();
+        /*void calculateArea(const SSquare& square);*/
+
+        void summonGameObjects();
+        void summonCreatures();
+        void removeCreature(ObjectGuid guid);
+        bool spawnFruitIfNeeded();
+
+        void reset();
+        bool isEnd() const;
+        void run(Player* player);
+
+        void updatePlayerStatus(EventMap& events, ObjectGuid guid);
+        void getPlayerPseudoPosition(int32_t& i, int32_t& j);
+
+        int32_t lifeCheck(Player* player, EventMap& events);
+        void handleFruit(ObjectGuid const& guid);
+        void movePlayerToStartPosition(Player* player, EventMap& events);
+
+        void pingGhosts(EPacmManHandlerAction action);
+        uint64 getGhostPosition(EPacmManHandlerAction action) const;
+
+        //DEBUG
+        std::string getPlayerPosition();
+
+    private:
+        std::unique_ptr<MapManager> _mapManager = nullptr;
+        std::unique_ptr<PathFinder> _pathFinder = nullptr;
+        std::unique_ptr<ObjectFactory> _objectFactory = nullptr;
+        std::unordered_map<ObjectGuid, GameObject*> _summonedObjects;
+        std::unordered_map<ObjectGuid, Creature*> _summonedCreatures;
+
+        Position _currentPlayerPosition;
+        Position _playerStartPosition;
+
+        /* delay UpdateAI case*/
+        std::pair<int32_t, int32_t> _previousPlayerPseudoPosition;
+
+        Creature* _blinky = nullptr;
+        Creature* _inky = nullptr;
+        Creature* _clyde = nullptr;
+
+        std::vector<Creature*> _lifeCounter;
+        std::vector<std::pair<int32_t, int32_t>> _fruitPositions;
+        std::stack<std::pair<int32_t, int32_t>> _fruitsHallOfFame;
+        int32_t _points = 0;
+
+        /* for fruit summon calculations */
+        int32_t _totalPoints = 0;
+        int32_t _summonedFruits = 0;
+
+
+        ::Map* _currentMap; // for find exist objects
+        bool _running;
+    };
+
+} // namespace PacMan
diff --git a/src/server/scripts/Custom/custom_script_loader.cpp b/src/server/scripts/Custom/custom_script_loader.cpp
index 9e5e9ba2bf..9830300433 100644
--- a/src/server/scripts/Custom/custom_script_loader.cpp
+++ b/src/server/scripts/Custom/custom_script_loader.cpp
@@ -16,9 +16,23 @@
  */

 // This is where scripts' loading functions should be declared:
+void AddSC_npc_pacman_handler();
+void AddSC_npc_regular_point();
+void AddSC_npc_blinky();
+void AddSC_npc_inky();
+void AddSC_npc_clyde();
+void AddSC_npc_bonus_point();
+void AddSC_npc_fruit();

 // The name of this function should match:
 // void Add${NameOfDirectory}Scripts()
 void AddCustomScripts()
 {
+    AddSC_npc_pacman_handler();
+    AddSC_npc_regular_point();
+    AddSC_npc_blinky();
+    AddSC_npc_inky();
+    AddSC_npc_clyde();
+    AddSC_npc_bonus_point();
+    AddSC_npc_fruit();
 }
diff --git a/src/server/scripts/Custom/npc_blinky.cpp b/src/server/scripts/Custom/npc_blinky.cpp
new file mode 100644
index 0000000000..7d71a43c04
--- /dev/null
+++ b/src/server/scripts/Custom/npc_blinky.cpp
@@ -0,0 +1,266 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+#include "PacmanMap.h"
+#include "SpellMgr.h"
+#include "GhostAI.h"
+class npc_blinky : public CreatureScript
+{
+public:
+    npc_blinky() : CreatureScript("npc_blinky") { }
+
+    struct npc_blinkyAI : public PacMan::GhostAI {
+
+        npc_blinkyAI(Creature* creature) : PacMan::GhostAI(creature) {
+        }
+
+        void InitializeAI() override {
+            PacMan::GhostAI::InitializeAI();
+
+            /* Define scatter positions */
+            _scatterPositions.push(PacMan::BLINKY_SCATTER_POS1);
+            _scatterPositions.push(PacMan::BLINKY_SCATTER_POS2);
+            _scatterPositions.push(PacMan::BLINKY_SCATTER_POS3);
+
+            _events.ScheduleEvent(PacMan::GHOST_DELAYED_START, PacMan::BLINKY_AI_DELAYED_START);
+        }
+
+        void DoAction(int32 action) override {
+            if (action == PacMan::GHOST_FIND_TARGET_POINT) {
+                switch (_state) {
+                    case PacMan::EAIState::AI_STATE_CHASE: {
+                        Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+                        if (!player) {
+                            return;
+                        }
+
+                        Position playerPosition = player->GetPosition();
+                        Position myPosition = me->GetPosition();
+
+                        std::pair<int32_t, int32_t> myPseudoPosition = _mapManager->toPseudoCellTransform(myPosition);
+                        std::pair<int32_t, int32_t> playerPseudoPosition = _mapManager->toPseudoCellTransform(playerPosition);
+
+                        if (myPseudoPosition == playerPseudoPosition) {
+                            return PacMan::GhostAI::PlayerCatched();
+                        }
+
+                        if (_forceChangePath || _pathFinder->isAdjacent(myPseudoPosition, _currentTarget) || !me->isMoving()) {
+                            _currentTarget = playerPseudoPosition;
+                            std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(myPseudoPosition, _currentTarget, 100));
+
+                            me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);
+
+                            /* The path calculation function may require significant resources but AI must be effective */
+                            _events.ScheduleEvent(PacMan::GHOST_CHASE_FORCE_RECALCULATE_PATH, 1500ms);
+                        }
+                        break;
+                    }
+//                     case PacMan::EAIState::AI_STATE_SCATTER: {
+//                         Position position = me->GetPosition();
+//                         std::pair<int32_t, int32_t> pseudoPosition = _mapManager->toPseudoCellTransform(position);
+//
+//                         if (myPseudoPosition == playerPseudoPosition) {
+//                             Unit* owner = me->GetOwner();
+//                             if (owner) {
+//                                 owner->GetAI()->DoAction(PacMan::BLINKY_WIN);
+//                             }
+//
+//                             /* TODO: add some visual effects */
+//
+// //                             _events.Reset();
+// //                             return;
+//                         }
+//
+//                         if (_pathFinder->isAdjacent(pseudoPosition, _currentTarget) || !me->isMoving() || _forceChangePath) {
+//                             std::pair<int32_t, int32_t> _currentTarget = _scatterPositions.front();
+//                             _scatterPositions.pop();
+//                             _scatterPositions.push(_currentTarget);
+//
+//                             std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(pseudoPosition, _currentTarget, 100));
+//                             me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);
+//                         }
+//                         break;
+//                     }
+//                     case PacMan::EAIState::AI_STATE_FRIGHTEND: {
+//                         if (myPseudoPosition == playerPseudoPosition) {
+//                             Unit* owner = me->GetOwner();
+//                             if (owner) {
+//                                 owner->GetAI()->DoAction(PacMan::BLINKY_LOSE);
+//                             }
+//
+//                             srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+//                             int32_t random = rand() % 10;
+//                             me->Say(PacMan::sprintf(PacMan::GHOST_SAYS_WHEN_WAS_EATEN[random], player->GetName().c_str()), LANG_UNIVERSAL);
+//
+//                             me->KillSelf();
+//                             _events.Reset();
+//                             _events.ScheduleEvent(PacMan::GHOST_BACK_TO_START, PacMan::GHOST_CORPSE_TELEPORT_TIME);
+//                             _events.ScheduleEvent(PacMan::GHOST_RESPAWN, PacMan::GHOST_RESPAWN_TIME);
+//
+//                             /* TODO: add some visual effects */
+//
+//                             return;
+//                         }
+//
+//                         if (_pathFinder->isAdjacent(myPseudoPosition, _currentTarget) || !me->isMoving() || _forceChangePath) {
+//                             std::pair<int32_t, int32_t> _currentTarget = _mapManager->getRandomNearPointEx(myPseudoPosition.first, myPseudoPosition.second);
+//                             std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(myPseudoPosition, _currentTarget, 42)); // depth an magic number need to tune this method
+//
+//                             me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);  //MovePath(path, false);
+//                         }
+//                         break;
+//                     }
+                    default:
+                        return PacMan::GhostAI::DoAction(action);
+                }
+
+                _forceChangePath = false;
+                _events.RescheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 100ms);
+            }
+//             else if (action == PacMan::INKY_WIN) {
+//                 srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+//                 int32_t random = rand() % 10;
+//                 me->Say(PacMan::sprintf(PacMan::GHOSTS_SAYS_WHEN_ANOTHER_ONE_CATCH_PLAYER[random], "Inky"), LANG_UNIVERSAL);
+//             }
+//             else if (action == PacMan::CLYDE_WIN) {
+//                 srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+//                 int32_t random = rand() % 10;
+//                 me->Say(PacMan::sprintf(PacMan::GHOSTS_SAYS_WHEN_ANOTHER_ONE_CATCH_PLAYER[random], "Clyde"), LANG_UNIVERSAL);
+//             }
+//             else if (action == PacMan::INKY_LOSE) {
+//                 srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+//                 int32_t random = rand() % 10;
+//                 me->Say(PacMan::sprintf(PacMan::GHOSTS_SAYS_WHEN_ANOTHER_ONE_IS_EATEN[random], "Inky"), LANG_UNIVERSAL);
+//             }
+//             else if (action == PacMan::CLYDE_LOSE) {
+//                 srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+//                 int32_t random = rand() % 10;
+//                 me->Say(PacMan::sprintf(PacMan::GHOSTS_SAYS_WHEN_ANOTHER_ONE_IS_EATEN[random], "Clyde"), LANG_UNIVERSAL);
+//             }
+            else if (action == PacMan::GHOST_WIN) {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    owner->GetAI()->DoAction(PacMan::BLINKY_WIN);
+                }
+            }
+            else if (action == PacMan::GHOST_LOSE) {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    owner->GetAI()->DoAction(PacMan::BLINKY_LOSE);
+                }
+            }
+            else {
+                return PacMan::GhostAI::DoAction(action);
+            }
+        }
+
+//         void UpdateAI(uint32 diff) override
+//         {
+//             _events.Update(diff);
+//
+//             switch (_events.ExecuteEvent()) {
+//                 case PacMan::GHOST_DELAYED_START: {
+//                     Unit* owner = me->GetOwner();
+//                     if (owner) {
+//                         _playerGuid = owner->GetAI()->GetGUID(PacMan::GET_CURRENT_PLAYER);
+//                     }
+//                     else {
+//                         _playerGuid = ObjectGuid::Empty;
+//                     }
+//                     me->RemoveAurasDueToSpell(PacMan::SPELL_STUN_VISUAL);
+//                     _state = PacMan::EAIState::AI_STATE_SCATTER;
+//                     Position _startPosition = me->GetPosition();
+//                     _currentTarget = _mapManager->toPseudoCellTransform(_startPosition);
+//                     _events.ScheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 1ms);
+//                     _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_SCATTER_TIME);
+//                     break;
+//                 }
+//                 case PacMan::GHOST_CHANGE_STATE: {
+//                     switch (_state)
+//                     {
+//                         case PacMan::EAIState::AI_STATE_CHASE: {
+//                             /*DEBUG*/
+//                             _state = PacMan::EAIState::AI_STATE_FRIGHTEND;
+//                             me->CastSpell(nullptr, PacMan::SPELL_FEAR_VISUAL);
+//                             me->CastSpell(nullptr, PacMan::SPELL_NPC_CHANGE_STATE_VISUAL);
+//                             _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_FRIGHTENED_TIME);
+//
+//                             Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+//                             if (player) {
+//                                 srand(static_cast<unsigned int>(time(nullptr)));
+//                                 int32_t random = rand() % 10;
+//                                 me->Yell(PacMan::sprintf(PacMan::GHOST_SAY_WHEN_WAS_FRIGHTENED[random], player->GetName().c_str()), LANG_UNIVERSAL);
+//                             }
+//                             /*DEBUG*/
+//                             break;
+//                         }
+//                         case PacMan::EAIState::AI_STATE_SCATTER: {
+//                             _state = PacMan::EAIState::AI_STATE_CHASE;
+//                             me->CastSpell(nullptr, PacMan::SPELL_NPC_CHANGE_STATE_VISUAL);
+//                             _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_CHASE_TIME);
+//                             break;
+//                         }
+//                         case PacMan::EAIState::AI_STATE_FRIGHTEND: {
+//                             _state = PacMan::EAIState::AI_STATE_SCATTER;
+//                             me->RemoveAurasDueToSpell(PacMan::SPELL_FEAR_VISUAL);
+//                             me->CastSpell(nullptr, PacMan::SPELL_NPC_CHANGE_STATE_VISUAL);
+//                             _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_SCATTER_TIME);
+//                             break;
+//                         }
+//                         default:
+//                             break;
+//                     }
+//                     _forceChangePath = true;
+//                     break;
+//                 }
+//                 case PacMan::GHOST_FIND_TARGET_POINT: {
+//                     DoAction(PacMan::GHOST_FIND_TARGET_POINT);
+//                     break;
+//                 }
+//                 case PacMan::GHOST_CHASE_FORCE_RECALCULATE_PATH: {
+//                     _forceChangePath = true;
+//                     break;
+//                 }
+//                 case PacMan::GHOST_BACK_TO_START: {
+//                     me->NearTeleportTo(_startPosition);
+//                 }
+//                 case PacMan::GHOST_RESPAWN: {
+//                     me->Respawn(true);
+//                     _state = PacMan::EAIState::AI_STATE_SCATTER;
+//                     Position _startPosition = me->GetPosition();
+//                     _currentTarget = _mapManager->toPseudoCellTransform(_startPosition);
+//                     _events.ScheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 1ms);
+//                     _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_SCATTER_TIME);
+//                 }
+//                 default:
+//                     break;
+//             }
+//         }
+//
+//     private:
+//         std::unique_ptr<PacMan::MapManager> _mapManager;
+//         std::unique_ptr <PacMan::PathFinder> _pathFinder;
+//
+//         PacMan::EAIState _state = PacMan::EAIState::AI_STATE_SCATTER;
+//         Position _startPosition;
+//         std::pair<int32_t, int32_t> _currentTarget;
+//         std::queue<std::pair<int32_t, int32_t>> _scatterPositions;
+//
+//         bool _forceChangePath = false;
+//
+//         ObjectGuid _playerGuid;
+//
+//         EventMap _events;
+    };
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_blinkyAI(creature);
+    }
+
+};
+
+void AddSC_npc_blinky()
+{
+    new npc_blinky();
+}
diff --git a/src/server/scripts/Custom/npc_bonus_point.cpp b/src/server/scripts/Custom/npc_bonus_point.cpp
new file mode 100644
index 0000000000..c69eb3ac55
--- /dev/null
+++ b/src/server/scripts/Custom/npc_bonus_point.cpp
@@ -0,0 +1,35 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "PacmanMap.h"
+
+class npc_bonus_point : public CreatureScript
+{
+public:
+    npc_bonus_point() : CreatureScript("npc_bonus_point") { }
+
+    struct npc_bonus_pointAI : public ScriptedAI {
+
+        npc_bonus_pointAI(Creature* creature) : ScriptedAI(creature) {}
+
+        void DoAction(int32 action) override {
+            if (action == PacMan::CREATURE_TOUCHED_BY_PLAYER) {
+                me->KillSelf(); // death animation
+                me->DespawnOrUnsummon(200ms); // delayed corpse despawn
+                Unit* owner = me->GetOwner();
+                if (owner)
+                    owner->GetAI()->SetGUID(me->GetGUID(), PacMan::BONUS_POINT_DESPAWN);
+            }
+        }
+
+    };
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_bonus_pointAI(creature);
+    }
+};
+
+void AddSC_npc_bonus_point()
+{
+    new npc_bonus_point();
+}
diff --git a/src/server/scripts/Custom/npc_clyde.cpp b/src/server/scripts/Custom/npc_clyde.cpp
new file mode 100644
index 0000000000..2fae519f60
--- /dev/null
+++ b/src/server/scripts/Custom/npc_clyde.cpp
@@ -0,0 +1,106 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+#include "PacmanMap.h"
+#include "SpellMgr.h"
+#include "GhostAI.h"
+
+class npc_clyde : public CreatureScript
+{
+public:
+    npc_clyde() : CreatureScript("npc_clyde") { }
+
+    struct npc_clydeAI : public PacMan::GhostAI {
+
+        npc_clydeAI(Creature* creature) : PacMan::GhostAI(creature) {
+        }
+
+        void InitializeAI() override {
+            PacMan::GhostAI::InitializeAI();
+            /* Define scatter positions */
+            _scatterPositions.push(PacMan::CLYDE_SCATTER_POS1);
+            _scatterPositions.push(PacMan::CLYDE_SCATTER_POS2);
+            _scatterPositions.push(PacMan::CLYDE_SCATTER_POS3);
+
+            if (PacMan::GHOSTS_START_BY_TIMER) {
+                _events.ScheduleEvent(PacMan::GHOST_DELAYED_START, PacMan::CLYDE_AI_DELAYED_START);
+            }
+            /* else trigger by eated points */
+        }
+
+        void DoAction(int32 action) override {
+            if (action == PacMan::GHOST_FIND_TARGET_POINT) {
+                switch (_state) {
+                    case PacMan::EAIState::AI_STATE_CHASE: {
+                        Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+                        if (!player) {
+                            return;
+                        }
+
+                        Position playerPosition = player->GetPosition();
+                        Position myPosition = me->GetPosition();
+
+                        std::pair<int32_t, int32_t> myPseudoPosition = _mapManager->toPseudoCellTransform(myPosition);
+                        std::pair<int32_t, int32_t> playerPseudoPosition = _mapManager->toPseudoCellTransform(playerPosition);
+
+                        if (myPseudoPosition == playerPseudoPosition) {
+                            return PacMan::GhostAI::PlayerCatched();
+                        }
+
+                        if (_forceChangePath || _pathFinder->isAdjacent(myPseudoPosition, _currentTarget) || !me->isMoving()) {
+
+                            int32_t distance = std::abs(playerPseudoPosition.first - myPseudoPosition.first) +
+                                               std::abs(playerPseudoPosition.second - myPseudoPosition.second);
+
+                            if (distance < PacMan::CLYDE_AI_CHASE_DISTANCE) {
+                                _currentTarget = _scatterPositions.front();
+                                _scatterPositions.pop();
+                                _scatterPositions.push(_currentTarget);
+                            }
+                            else {
+                                _currentTarget = playerPseudoPosition;
+                            }
+
+                            std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(myPseudoPosition, _currentTarget, 100));
+
+                            me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);
+
+                            /* The path calculation function may require significant resources but AI must be effective */
+                            _events.ScheduleEvent(PacMan::GHOST_CHASE_FORCE_RECALCULATE_PATH, 1500ms);
+                        }
+                        break;
+                    }
+                    default:
+                        return PacMan::GhostAI::DoAction(action);
+                }
+                _forceChangePath = false;
+                _events.RescheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 100ms);
+            }
+            else if (action == PacMan::GHOST_WIN) {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    owner->GetAI()->DoAction(PacMan::CLYDE_WIN);
+                }
+            }
+            else if (action == PacMan::GHOST_LOSE) {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    owner->GetAI()->DoAction(PacMan::CLYDE_LOSE);
+                }
+            }
+            else {
+                return PacMan::GhostAI::DoAction(action);
+            }
+        }
+    };
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_clydeAI(creature);
+    }
+};
+
+void AddSC_npc_clyde()
+{
+    new npc_clyde();
+}
diff --git a/src/server/scripts/Custom/npc_fruit.cpp b/src/server/scripts/Custom/npc_fruit.cpp
new file mode 100644
index 0000000000..bf54029070
--- /dev/null
+++ b/src/server/scripts/Custom/npc_fruit.cpp
@@ -0,0 +1,50 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "PacmanMap.h"
+
+class npc_fruit : public CreatureScript
+{
+public:
+    npc_fruit() : CreatureScript("npc_fruit") { }
+
+    struct npc_fruitAI : public ScriptedAI {
+
+        npc_fruitAI(Creature* creature) : ScriptedAI(creature) {}
+
+        void InitializeAI() override {
+            me->CastSpell(nullptr, PacMan::SPELL_NPC_TELEPORT_VISUAL);
+            events.ScheduleEvent(PacMan::FRUIT_DESPAWN, PacMan::FRUIT_LIFETIME);
+        }
+
+        void DoAction(int32 action) override {
+            if (action == PacMan::CREATURE_TOUCHED_BY_PLAYER) {
+                Unit* owner = me->GetOwner();
+                if (owner)
+                    owner->GetAI()->SetGUID(me->GetGUID(), PacMan::MOVE_FRUIT);
+                events.Reset();
+            }
+        }
+
+        void UpdateAI(uint32 diff) override {
+            events.Update(diff);
+
+            if (events.ExecuteEvent() == PacMan::FRUIT_DESPAWN) {
+                me->KillSelf();
+                me->DespawnOrUnsummon(500ms);
+            }
+        }
+
+    private:
+        EventMap events;
+    };
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_fruitAI(creature);
+    }
+};
+
+void AddSC_npc_fruit()
+{
+    new npc_fruit();
+}
diff --git a/src/server/scripts/Custom/npc_inky.cpp b/src/server/scripts/Custom/npc_inky.cpp
new file mode 100644
index 0000000000..a83bcaad3a
--- /dev/null
+++ b/src/server/scripts/Custom/npc_inky.cpp
@@ -0,0 +1,230 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+#include "PacmanMap.h"
+#include "SpellMgr.h"
+#include "GhostAI.h"
+class npc_inky : public CreatureScript
+{
+public:
+    npc_inky() : CreatureScript("npc_inky") { }
+
+    struct npc_inkyAI : public PacMan::GhostAI {
+
+        npc_inkyAI(Creature* creature) : PacMan::GhostAI(creature) {
+        }
+
+        void InitializeAI() override {
+            PacMan::GhostAI::InitializeAI();
+
+            /* Define scatter positions */
+            _scatterPositions.push(PacMan::INKY_SCATTER_POS1);
+            _scatterPositions.push(PacMan::INKY_SCATTER_POS2);
+            _scatterPositions.push(PacMan::INKY_SCATTER_POS3);
+
+            if (PacMan::GHOSTS_START_BY_TIMER) {
+                _events.ScheduleEvent(PacMan::GHOST_DELAYED_START, PacMan::INKY_AI_DELAYED_START);
+            }
+            /* else trigger by eated points */
+        }
+
+        void DoAction(int32 action) override {
+            if (action == PacMan::GHOST_FIND_TARGET_POINT) {
+                switch (_state) {
+                    case PacMan::EAIState::AI_STATE_CHASE: {
+                        Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+                        if (!player) {
+                            return;
+                        }
+
+                        Position playerPosition = player->GetPosition();
+                        Position myPosition = me->GetPosition();
+
+                        std::pair<int32_t, int32_t> myPseudoPosition = _mapManager->toPseudoCellTransform(myPosition);
+                        std::pair<int32_t, int32_t> playerPseudoPosition = _mapManager->toPseudoCellTransform(playerPosition);
+
+                        if (myPseudoPosition == playerPseudoPosition) {
+                            return PacMan::GhostAI::PlayerCatched();
+                        }
+
+                        if (_forceChangePath || _pathFinder->isAdjacent(myPseudoPosition, _currentTarget) || !me->isMoving()) {
+                            _currentTarget =  _mapManager->getNearestAvailablePoint(CalculateTarget(playerPseudoPosition));
+                            std::vector<Position> path = _mapManager->toWaypointPathTransform(_pathFinder->findPath(myPseudoPosition, _currentTarget, 100));
+
+                            me->GetMotionMaster()->MoveSmoothPath(0, path.data(), path.size(), false);
+
+                            /* The path calculation function may require significant resources but AI must be effective */
+                            _events.ScheduleEvent(PacMan::GHOST_CHASE_FORCE_RECALCULATE_PATH, 1500ms);
+                        }
+                        break;
+                    }
+                    default:
+                        return PacMan::GhostAI::DoAction(action);
+                }
+
+                _forceChangePath = false;
+                _events.RescheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 100ms);
+            }
+            else if (action == PacMan::GHOST_WIN) {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    owner->GetAI()->DoAction(PacMan::INKY_WIN);
+                }
+            }
+            else if (action == PacMan::GHOST_LOSE) {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    owner->GetAI()->DoAction(PacMan::INKY_LOSE);
+                }
+            }
+            else {
+                return PacMan::GhostAI::DoAction(action);
+            }
+        }
+
+//         void UpdateAI(uint32 diff) override
+//         {
+//             _events.Update(diff);
+//
+//             switch (_events.ExecuteEvent()) {
+//                 case PacMan::GHOST_DELAYED_START: {
+//                     Unit* owner = me->GetOwner();
+//                     if (owner) {
+//                         _playerGuid = owner->GetAI()->GetGUID(PacMan::GET_CURRENT_PLAYER);
+//                     }
+//                     else {
+//                         _playerGuid = ObjectGuid::Empty;
+//                     }
+//                     me->RemoveAurasDueToSpell(PacMan::SPELL_STUN_VISUAL);
+//                     _state = PacMan::EAIState::AI_STATE_SCATTER;
+//                     Position myPosition = me->GetPosition();
+//                     _currentTarget = _mapManager->toPseudoCellTransform(myPosition);
+//                     _events.ScheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 1ms);
+//                     _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_SCATTER_TIME);
+//                     break;
+//                 }
+//                 case PacMan::GHOST_CHANGE_STATE: {
+//                     switch (_state) {
+//                         case PacMan::EAIState::AI_STATE_CHASE: {
+//                             /*DEBUG*/
+//                             _state = PacMan::EAIState::AI_STATE_FRIGHTEND;
+//                             me->CastSpell(nullptr, PacMan::SPELL_FEAR_VISUAL);
+//                             me->CastSpell(nullptr, PacMan::SPELL_NPC_CHANGE_STATE_VISUAL);
+//                             _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_FRIGHTENED_TIME);
+//
+//                             Player* player = ObjectAccessor::GetPlayer(me->GetMap(), _playerGuid);
+//                             if (player) {
+//                                 srand(static_cast<unsigned int>(time(nullptr) / 2 + me->GetGUID().GetRawValue()));
+//                                 int32_t random = rand() % 10;
+//                                 me->Yell(PacMan::sprintf(PacMan::GHOST_SAY_WHEN_WAS_FRIGHTENED[random], player->GetName().c_str()), LANG_UNIVERSAL);
+//                             }
+//                             /*DEBUG*/
+//                             break;
+//                         }
+//                         case PacMan::EAIState::AI_STATE_SCATTER: {
+//                             _state = PacMan::EAIState::AI_STATE_CHASE;
+//                             me->CastSpell(nullptr, PacMan::SPELL_NPC_CHANGE_STATE_VISUAL);
+//                             _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_CHASE_TIME);
+//                             break;
+//                         }
+//                         case PacMan::EAIState::AI_STATE_FRIGHTEND: {
+//                             _state = PacMan::EAIState::AI_STATE_SCATTER;
+//                             me->RemoveAurasDueToSpell(PacMan::SPELL_FEAR_VISUAL);
+//                             me->CastSpell(nullptr, PacMan::SPELL_NPC_CHANGE_STATE_VISUAL);
+//                             _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_SCATTER_TIME);
+//                             break;
+//                         }
+//                         default:
+//                             break;
+//                     }
+//                     _forceChangePath = true;
+//                     break;
+//                 }
+//                 case PacMan::GHOST_FIND_TARGET_POINT: {
+//                     DoAction(PacMan::GHOST_FIND_TARGET_POINT);
+//                     break;
+//                 }
+//                 case PacMan::GHOST_CHASE_FORCE_RECALCULATE_PATH: {
+//                     _forceChangePath = true;
+//                     break;
+//                 }
+//                 case PacMan::GHOST_BACK_TO_START: {
+//                     me->NearTeleportTo(_startPosition);
+//                 }
+//                 case PacMan::GHOST_RESPAWN: {
+//                     me->Respawn(true);
+//                     _state = PacMan::EAIState::AI_STATE_SCATTER;
+//                     Position _startPosition = me->GetPosition();
+//                     _currentTarget = _mapManager->toPseudoCellTransform(_startPosition);
+//                     _events.ScheduleEvent(PacMan::GHOST_FIND_TARGET_POINT, 1ms);
+//                     _events.ScheduleEvent(PacMan::GHOST_CHANGE_STATE, PacMan::GHOST_AI_SCATTER_TIME);
+//                 }
+//                 default:
+//                     break;
+//             }
+//         }
+    private:
+
+        std::pair<int32_t, int32_t> CalculateTarget(const std::pair<int32_t, int32_t>& playerPosition) {
+            Unit* owner = me->GetOwner();
+            if (!owner) {
+                return playerPosition;
+            }
+
+            ObjectGuid blinkyPosition = owner->GetAI()->GetGUID(PacMan::GET_BLINKY_POSITION);
+            uint64 coordinates = blinkyPosition.GetRawValue();
+
+            /* unpack */
+            uint16_t num = 0x01;
+            uint8_t* ptr = reinterpret_cast<uint8_t*>(&num);
+            bool isBigEndian = ptr[0] == 0x00;
+
+            std::pair<int32_t, int32_t> blinkyPseudoPosition;
+            if (isBigEndian) {
+                coordinates = (coordinates >> 32) | (coordinates << 32);
+            }
+            blinkyPseudoPosition.first = static_cast<uint32_t>(coordinates >> 32);
+            blinkyPseudoPosition.second = static_cast<uint32_t>(coordinates);
+            /* end unpack */
+
+            /* vector from blinky to player */
+            int32_t vectorJ = playerPosition.second - blinkyPseudoPosition.second;
+            int32_t vectorI = playerPosition.first - blinkyPseudoPosition.first;
+
+            int32_t targetI = playerPosition.first + vectorI;
+            int32_t targetJ = playerPosition.second + vectorJ;
+
+            if (targetI < 0) targetI = 0;
+            if (targetI >= _mapManager->getMapInfo().height) targetI = _mapManager->getMapInfo().height - 1;
+            if (targetJ < 0) targetJ = 0;
+            if (targetJ >= _mapManager->getMapInfo().width) targetJ = _mapManager->getMapInfo().width - 1;
+
+            return { targetI, targetJ };
+        }
+
+//     private:
+//         std::unique_ptr<PacMan::MapManager> _mapManager;
+//         std::unique_ptr <PacMan::PathFinder> _pathFinder;
+//
+//         PacMan::EAIState _state = PacMan::EAIState::AI_STATE_SCATTER;
+//         Position _startPosition;
+//         std::pair<int32_t, int32_t> _currentTarget;
+//         std::queue<std::pair<int32_t, int32_t>> _scatterPositions;
+//
+//         bool _forceChangePath = false;
+//
+//         ObjectGuid _playerGuid;
+//
+//         EventMap _events;
+    };
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_inkyAI(creature);
+    }
+};
+
+void AddSC_npc_inky()
+{
+    new npc_inky();
+}
diff --git a/src/server/scripts/Custom/npc_pacman_handler.cpp b/src/server/scripts/Custom/npc_pacman_handler.cpp
new file mode 100644
index 0000000000..8882e10f02
--- /dev/null
+++ b/src/server/scripts/Custom/npc_pacman_handler.cpp
@@ -0,0 +1,448 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Define.h"
+#include "SharedDefines.h"
+#include "Unit.h"
+#include "ScriptedGossip.h"
+#include "TaskScheduler.h"
+#include "PacmanMap.h"
+#include "DBCStores.h"
+#include "DBCStructure.h"
+#include "ObjectMgr.h"
+#include "Position.h"
+#include "PacmanMap.h"
+#include "GridNotifiers.h"
+#include "EventMap.h"
+
+class npc_pacman_handler : public CreatureScript
+{
+public:
+    npc_pacman_handler() : CreatureScript("npc_pacman_handler") { }
+
+    struct npc_pacman_handlerAI : public ScriptedAI {
+
+        npc_pacman_handlerAI(Creature* creature) : ScriptedAI(creature) , _eventControler()
+        {
+        }
+
+        void InitializeAI() override
+        {
+            AreaTrigger const* at = sObjectMgr->GetAreaTriggerEx(PacMan::AT_PLAYER_START);
+            if (at != nullptr) {
+                me->GetMotionMaster()->MovePoint(PacMan::AT_PLAYER_START, { at->target_X, at->target_Y, at->target_Z }, true, at->target_Orientation);
+            }
+            else {
+                me->GetMotionMaster()->MovePoint(PacMan::AT_PLAYER_START, me->GetHomePosition());
+            }
+            _default_position = me->GetPosition();
+            if (_playerGuid != ObjectGuid::Empty) {
+                Player* player = ObjectAccessor::FindPlayer(_playerGuid);
+                if (player) {
+                    /* just in case, i cannot modify DBC so i use infinity visual auras on player.
+                       This may require GM intervention in case of disconnection, for example but will handle the teleport/summon case */
+                    player->RemoveAurasDueToSpell(PacMan::SPELL_STUN_VISUAL);
+                    player->RemoveAurasDueToSpell(PacMan::SPELL_EVENT_AURA_DAMAGE);
+                    player->RemoveAurasDueToSpell(PacMan::SPELL_EVENT_AURA);
+                    player->RemoveAurasDueToSpell(PacMan::SPELL_SPHERE_VISUAL);
+                }
+            }
+            _playerSuperpower = 0;
+            _playerKillSpree = 0;
+            _playerScore = 0;
+            _playerGuid = ObjectGuid::Empty;
+            _events.Reset();
+            _eventControler.reset();
+        }
+
+        void Reset() override
+        {
+            InitializeAI();
+        }
+
+        void OnDespawn() override
+        {
+            Reset();
+        }
+
+        void ReceiveEmote(Player* player, uint32 emote) override
+        {
+        }
+
+        bool OnGossipHello(Player* player) override
+        {
+            if (_eventControler.isRuning()) {
+                CloseGossipMenuFor(player);
+                if (player->GetGUID() == _playerGuid) {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Stop event", 0, PacMan::PC_GOSSIP_STOP_EVENT);
+                }
+                else {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Set 4 minutes (by default) deadline for current player", 0, PacMan::PC_GOSSIP_SET_DEADLINE);
+                }
+                SendGossipMenuFor(player, player->GetGossipTextId(me) + 1, me); // creature busy message not the best solution to increment the current id
+            }
+            else {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Let's start!", 0, 0);
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Event demonstration. Ghosts will stay on them positions", 0, PacMan::PC_GOSSIP_DEBUG_IDLE_GHOSTS);
+
+                auto const& score = _leaderBoardCache[player->GetGUID()];
+                if (score.first != 0) {
+                    AddGossipItemFor(player, GOSSIP_ICON_BATTLE, PacMan::sprintf("Your previous try scores: %u.", score.first), 0, PacMan::PC_GOSSIP_DUMMY);
+                }
+                if (score.second != 0) {
+                    AddGossipItemFor(player, GOSSIP_ICON_BATTLE, PacMan::sprintf("Your previous record: %u.", score.second), 0, PacMan::PC_GOSSIP_DUMMY);
+                }
+                SendGossipMenuFor(player, player->GetGossipTextId(me), me);
+            }
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, uint32 sender, uint32 gossipListId) override
+        {
+            if (!player) {
+                return false;
+            }
+
+            uint32 const action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+
+            if (action == 0 || action == PacMan::PC_GOSSIP_DEBUG_IDLE_GHOSTS) {
+                ClearGossipMenuFor(player);
+                me->Say("Let's start!", LANG_UNIVERSAL);
+                CloseGossipMenuFor(player);
+                _playerGuid = player->GetGUID();
+
+                try {
+                    /*There is space here for handling errors in calculations, which is omitted because it is beyond the scope of the task.*/
+                    _eventControler.prepareEvent(*me);
+/*                    _eventControler.calculateArea(PacMan::POS_MAP);*/
+                    _eventControler.summonGameObjects();
+                    _eventControler.summonCreatures();
+
+                    _eventControler.run(player);
+                    if (action == PacMan::PC_GOSSIP_DEBUG_IDLE_GHOSTS) {
+                        _eventControler.pingGhosts(PacMan::STOP_GHOSTS);
+                    }
+                    _events.ScheduleEvent(PacMan::CHECK_PLAYER_POSITION, 500ms);
+                }
+                catch (std::exception& /*e*/) {
+                     me->Say("Not today, Honey", LANG_UNIVERSAL);
+                     Reset();
+                     return true;
+                }
+
+                AreaTrigger const* at = sObjectMgr->GetAreaTriggerEx(PacMan::AT_NPC_VANTAGE);
+                if (at) {
+                    me->NearTeleportTo({ at->target_X, at->target_Y, at->target_Z, at->target_Orientation }, true);
+                    me->CastSpell(nullptr, PacMan::SPELL_NPC_TELEPORT_VISUAL);
+                    _events.ScheduleEvent(PacMan::SHOW_TELEPORT_VISUAL, 1ms);
+                    _events.ScheduleEvent(PacMan::TELEPORT_PLAYER_AT_START, 20ms);
+                }
+                return true;
+            }
+            else if (action == PacMan::PC_GOSSIP_STOP_EVENT) {
+                ClearGossipMenuFor(player);
+                me->Say("See you later!", LANG_UNIVERSAL);
+                CloseGossipMenuFor(player);
+                Reset();
+                return true;
+            }
+            else if (action == PacMan::PC_GOSSIP_SET_DEADLINE) {
+                ClearGossipMenuFor(player);
+                if (_eventControler.isRuning()) {
+                    me->Yell(PacMan::sprintf("hurry up %s, you only have 4 minutes", player->GetName().c_str()), LANG_UNIVERSAL);
+                    _events.ScheduleEvent(PacMan::STOP_FAIL, PacMan::EVENT_DEADLINE);
+                }
+                return true;
+            }
+            return false;
+        }
+        void UpdateAI(uint32 diff) override
+        {
+//             _checkPlayers += diff;
+//             if (_checkPlayers > 10000 && _eventControler.isRuning()) {
+//                 std::list<Player*> players;
+//                 Trinity::AnyPlayerInObjectRangeCheck check(me, 120, false);  // check alive and dead players
+//                 Trinity::PlayerListSearcher<Trinity::AnyPlayerInObjectRangeCheck> searcher(me, players, check);
+//                 Cell::VisitWorldObjects(me, searcher, 120);
+//                 if (players.empty()) {
+//                     Reset();
+//                 }
+//                 _checkPlayers = 0;
+//             }
+            _events.Update(diff);
+
+            switch (_events.ExecuteEvent())
+            {
+                case PacMan::CHECK_PLAYER_POSITION: {
+                    _eventControler.updatePlayerStatus(_events, _playerGuid);
+                    _events.RescheduleEvent(PacMan::CHECK_PLAYER_POSITION, 200ms);
+                    break;
+                }
+                case PacMan::REMOVE_PLAYER_STUN: {
+                   Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                   if (!player) {
+                       return;
+                   }
+
+                   player->RemoveAurasDueToSpell(PacMan::SPELL_STUN_VISUAL);
+                   _events.ScheduleEvent(PacMan::PLAYER_STARTED, 1ms);
+                   break;
+                }
+                case PacMan::SHOW_TELEPORT_VISUAL: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    player->CastSpell(nullptr, PacMan::SPELL_PLAYER_TELEPORT_VISUAL);
+                    break;
+                }
+                case PacMan::TELEPORT_PLAYER_AT_START: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    _eventControler.movePlayerToStartPosition(player, _events);
+                    break;
+                }
+                case PacMan::RENEW_EVENT_AURA_DAMAGE: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    player->CastSpell(player, PacMan::SPELL_EVENT_AURA_DAMAGE);
+                    _events.RescheduleEvent(PacMan::RENEW_EVENT_AURA_DAMAGE, PacMan::EVENT_AURA_STACK_SPEED);
+                    break;
+                }
+                case PacMan::RENEW_EVENT_AURA: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    player->RemoveAurasDueToSpell(PacMan::SPELL_EVENT_AURA);
+                    player->CastSpell(player, PacMan::SPELL_EVENT_AURA);
+                    _events.RescheduleEvent(PacMan::RENEW_EVENT_AURA, 8s);
+                    break;
+                }
+                case PacMan::PLAYER_STARTED: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    player->CastSpell(player, PacMan::SPELL_EVENT_AURA);
+                    /* and first stack */
+                    player->CastSpell(player, PacMan::SPELL_EVENT_AURA_DAMAGE);
+                    _events.ScheduleEvent(PacMan::RENEW_EVENT_AURA_DAMAGE, PacMan::EVENT_AURA_STACK_SPEED);
+                    _events.ScheduleEvent(PacMan::RENEW_EVENT_AURA, 8s);
+                    break;
+                }
+                case PacMan::REMOVE_SPHERE_VISUAL: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    _playerSuperpower = 0;
+                    _playerKillSpree = 0;
+                    player->RemoveAurasDueToSpell(PacMan::SPELL_SPHERE_VISUAL);
+                    break;
+                }
+                case PacMan::STOP_FAIL: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        Reset();
+                        return;
+                    }
+
+                    std::pair<uint32, uint32>& scores = _leaderBoardCache[_playerGuid];
+                    scores.first = _playerScore;
+                    /* i think we should not save scores in fail event case */
+                    /*scores.second = std::max(scores.second, _playerScore);*/
+                    me->Yell(PacMan::sprintf("You only scored %d points, %s. Not impressive.", _playerScore, player->GetName().c_str()), LANG_UNIVERSAL);
+                    Reset();
+                    break;
+                }
+                case PacMan::STOP_SUCCESS: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        Reset();
+                        return;
+                    }
+
+                    std::pair<uint32, uint32>& scores = _leaderBoardCache[_playerGuid];
+                    scores.first = _playerScore;
+                    scores.second = std::max(scores.second, _playerScore);
+                    me->Yell(PacMan::sprintf("Congratulations on winning! Your score of %d points, %s, is absolutely impressive!", _playerScore, player->GetName().c_str()), LANG_UNIVERSAL);
+                    Reset();
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+
+
+        void DoAction(int32 action) override
+        {
+            switch (action)
+            {
+                case PacMan::REGULAR_POINT_DESPAWN: {
+                    if (_eventControler.isRuning()) {
+                        Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                        if (!player) {
+                            return;
+                        }
+
+                        player->RemoveAuraFromStack(PacMan::SPELL_EVENT_AURA_DAMAGE);
+                        player->RegenerateHealth();
+                        player->CastSpell(player, PacMan::SPELL_EVENT_AURA_DECREASE_SPEED);
+
+                        if (_eventControler.isEnd()) {
+                            /* reuse action for stopping the ghosts */
+                            _eventControler.pingGhosts(PacMan::BONUS_POINT_DESPAWN_HA);
+                            _events.Reset();
+                            _events.ScheduleEvent(PacMan::STOP_SUCCESS, 1s);
+                        }
+                    }
+                    break;
+                }
+                case PacMan::BLINKY_WIN:
+                case PacMan::INKY_WIN:
+                case PacMan::CLYDE_WIN: {
+                    _eventControler.pingGhosts(static_cast<PacMan::EPacmManHandlerAction>(action));
+
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    int32_t lifes = _eventControler.lifeCheck(player, _events);
+                    if (lifes == 0) {
+                        _events.ScheduleEvent(PacMan::STOP_FAIL, 1ms);
+                    }
+                    break;
+                }
+                case PacMan::BLINKY_LOSE:
+                case PacMan::INKY_LOSE:
+                case PacMan::CLYDE_LOSE: {
+                    _eventControler.pingGhosts(static_cast<PacMan::EPacmManHandlerAction>(action));
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    uint64 now = static_cast<uint64>(time(nullptr));
+                    uint32 score = 0;
+                    // just ignore C4018
+                    if (now - _playerSuperpower <= std::chrono::duration_cast<std::chrono::seconds>(PacMan::GHOST_AI_FRIGHTENED_TIME).count()) {
+                        ++_playerKillSpree;
+                        score = PacMan::SCORE_GHOST_EATEN * _playerKillSpree;
+                        _playerScore += score;
+                    }
+                    else {
+                        /* possible delay */
+                        score = PacMan::SCORE_GHOST_EATEN * ((_playerKillSpree == 0) ? 1 : 0);
+                        _playerScore += score;
+                    }
+                    me->Yell(PacMan::sprintf("Nice one! %s got %u point!", player->GetName(), score), LANG_UNIVERSAL);
+                    break;
+                }
+                case PacMan::BONUS_POINT_DESPAWN: {
+                    Player* player = me->GetMap()->GetPlayer(_playerGuid);
+                    if (!player) {
+                        return;
+                    }
+
+                    player->CastSpell(nullptr, PacMan::SPELL_SPHERE_VISUAL);
+                    _playerSuperpower = static_cast<uint64>(time(nullptr));
+                    _events.ScheduleEvent(PacMan::REMOVE_SPHERE_VISUAL, PacMan::GHOST_AI_FRIGHTENED_TIME);
+                    _eventControler.pingGhosts(static_cast<PacMan::EPacmManHandlerAction>(action));
+                    if (_eventControler.isEnd()) {
+                        _events.Reset();
+                        _events.ScheduleEvent(PacMan::STOP_SUCCESS, 1s);
+                    }
+                }
+                default:
+                    break;
+            }
+        }
+
+        ObjectGuid GetGUID(int32 guidIndex) const override
+        {
+            if (guidIndex == PacMan::GET_CURRENT_PLAYER) {
+                return _playerGuid;
+            }
+            else if (guidIndex == PacMan::GET_BLINKY_POSITION) {
+                /* little trick */
+                ObjectGuid result(_eventControler.getGhostPosition(PacMan::BLINKY));
+                return result;
+            }
+            return ObjectGuid::Empty;
+        }
+
+
+        void SetGUID(ObjectGuid const& guid, int32 action) override
+        {
+            if (action == PacMan::REGULAR_POINT_DESPAWN) {
+                _eventControler.removeCreature(guid);
+                if (_eventControler.spawnFruitIfNeeded()) {
+                    me->Yell("Yammy!", LANG_UNIVERSAL);
+                }
+                _playerScore += PacMan::SCORE_REGULAR_POINT;
+                DoAction(action);
+            }
+            else if (action == PacMan::BONUS_POINT_DESPAWN) {
+                _eventControler.removeCreature(guid);
+                if (_eventControler.spawnFruitIfNeeded()) {
+                    me->Yell("Yammy!", LANG_UNIVERSAL);
+                }
+                _playerScore += PacMan::SCORE_POWER_POINT;
+                DoAction(action);
+            }
+            else if (action == PacMan::MOVE_FRUIT) {
+                _eventControler.handleFruit(guid);
+            }
+//             switch (action)
+//             {
+//                 case PacMan::REGULAR_POINT_DESPAWN: {
+//                     DoAction(action);
+//                     _eventControler.removeCreature(guid);
+//                     break;
+//                 }
+//             default:
+//                 break;
+//             }
+        }
+
+    private:
+        Position _default_position;
+/*        uint32 _checkPlayers = 0;*/
+        EventMap _events;
+        ObjectGuid _playerGuid;
+
+        /* registr killspree */
+        uint64 _playerSuperpower = 0;
+        uint32 _playerKillSpree = 0;
+
+        uint32 _playerScore = 0;
+
+        std::unordered_map<ObjectGuid, std::pair<uint32, uint32>> _leaderBoardCache;
+        PacMan::EventController _eventControler;
+    };
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_pacman_handlerAI(creature);
+    }
+
+};
+
+void AddSC_npc_pacman_handler()
+{
+    new npc_pacman_handler();
+}
diff --git a/src/server/scripts/Custom/npc_regular_point.cpp b/src/server/scripts/Custom/npc_regular_point.cpp
new file mode 100644
index 0000000000..6d15022a29
--- /dev/null
+++ b/src/server/scripts/Custom/npc_regular_point.cpp
@@ -0,0 +1,72 @@
+#include "SmartAI.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "PacmanMap.h"
+
+class npc_regular_point : public CreatureScript
+{
+public:
+    npc_regular_point() : CreatureScript("npc_regular_point") { }
+
+    struct npc_regular_pointAI : public ScriptedAI {
+
+        npc_regular_pointAI(Creature* creature) : ScriptedAI(creature) {}
+
+
+
+        void OnDespawn() override
+        {
+        }
+
+        void DoAction(int32 action) override {
+            if (action == PacMan::CREATURE_TOUCHED_BY_PLAYER) {
+                me->KillSelf(); // death animation
+                me->DespawnOrUnsummon(200ms); // delayed corpse despawn
+                Unit* owner = me->GetOwner();
+                if (owner)
+                    owner->GetAI()->SetGUID(me->GetGUID(), PacMan::REGULAR_POINT_DESPAWN);
+            }
+        }
+
+
+        /* This solution works very slowly, I'll leave it for history */
+        void UpdateAI(uint32 diff) override
+        {
+           /* events.Update(diff);*/
+
+/*            if (events.ExecuteEvent() == PacMan::CHECK_TOUCHED_BY_PLAYER)
+            {
+                Unit* owner = me->GetOwner();
+                if (owner) {
+                    _currentPlayer = owner->GetAI()->GetGUID(PacMan::GET_CURRENT_PLAYER);
+                    std::list<Player*> players;
+                    me->GetPlayerListInGrid(players, 0.1f); // probably there are minimum distance normalized > 0.1f
+                    for (auto&player : players) {
+                        if (player->GetGUID() == _currentPlayer) {
+                            if (me->GetExactDist(player->GetPosition()) < 1.0f) {
+                                me->KillSelf(); // death animation
+                                me->DespawnOrUnsummon(100ms);
+                            }
+                            return;
+                        }
+                    }
+                }
+            }
+            events.RescheduleEvent(PacMan::CHECK_TOUCHED_BY_PLAYER, 50ms);
+            */
+        }
+
+    private:
+//         ObjectGuid _currentPlayer;
+//         EventMap events;
+    };
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_regular_pointAI(creature);
+    }
+};
+
+void AddSC_npc_regular_point()
+{
+    new npc_regular_point();
+}
